// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dedupv1d.proto

#ifndef PROTOBUF_dedupv1d_2eproto__INCLUDED
#define PROTOBUF_dedupv1d_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dedupv1d_2eproto();
void protobuf_AssignDesc_dedupv1d_2eproto();
void protobuf_ShutdownFile_dedupv1d_2eproto();

class OptionPair;
class VolumeInfoData;
class ScsiResultData;
class CommandErrorReportData;
class CommandErrorReportsData;
class VolumeInfoDetachingData;
class VolumeFastCopyJobData;
class VolumeInfoFastCopyData;
class GroupInfoData;
class TargetAuthData;
class TargetInfoData;
class UserInfoData;
class DirtyFileData;

enum VolumeInfoStateData {
  VOLUME_STATE_RUNNING = 0,
  VOLUME_STATE_MAINTENANCE = 1
};
bool VolumeInfoStateData_IsValid(int value);
const VolumeInfoStateData VolumeInfoStateData_MIN = VOLUME_STATE_RUNNING;
const VolumeInfoStateData VolumeInfoStateData_MAX = VOLUME_STATE_MAINTENANCE;
const int VolumeInfoStateData_ARRAYSIZE = VolumeInfoStateData_MAX + 1;

const ::google::protobuf::EnumDescriptor* VolumeInfoStateData_descriptor();
inline const ::std::string& VolumeInfoStateData_Name(VolumeInfoStateData value) {
  return ::google::protobuf::internal::NameOfEnum(
    VolumeInfoStateData_descriptor(), value);
}
inline bool VolumeInfoStateData_Parse(
    const ::std::string& name, VolumeInfoStateData* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VolumeInfoStateData>(
    VolumeInfoStateData_descriptor(), name, value);
}
// ===================================================================

class OptionPair : public ::google::protobuf::Message {
 public:
  OptionPair();
  virtual ~OptionPair();

  OptionPair(const OptionPair& from);

  inline OptionPair& operator=(const OptionPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionPair& default_instance();

  void Swap(OptionPair* other);

  // implements Message ----------------------------------------------

  OptionPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OptionPair& from);
  void MergeFrom(const OptionPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string option_name = 1;
  inline bool has_option_name() const;
  inline void clear_option_name();
  static const int kOptionNameFieldNumber = 1;
  inline const ::std::string& option_name() const;
  inline void set_option_name(const ::std::string& value);
  inline void set_option_name(const char* value);
  inline void set_option_name(const char* value, size_t size);
  inline ::std::string* mutable_option_name();
  inline ::std::string* release_option_name();
  inline void set_allocated_option_name(::std::string* option_name);

  // required string option = 2;
  inline bool has_option() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 2;
  inline const ::std::string& option() const;
  inline void set_option(const ::std::string& value);
  inline void set_option(const char* value);
  inline void set_option(const char* value, size_t size);
  inline ::std::string* mutable_option();
  inline ::std::string* release_option();
  inline void set_allocated_option(::std::string* option);

  // @@protoc_insertion_point(class_scope:OptionPair)
 private:
  inline void set_has_option_name();
  inline void clear_has_option_name();
  inline void set_has_option();
  inline void clear_has_option();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* option_name_;
  ::std::string* option_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static OptionPair* default_instance_;
};
// -------------------------------------------------------------------

class VolumeInfoData : public ::google::protobuf::Message {
 public:
  VolumeInfoData();
  virtual ~VolumeInfoData();

  VolumeInfoData(const VolumeInfoData& from);

  inline VolumeInfoData& operator=(const VolumeInfoData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VolumeInfoData& default_instance();

  void Swap(VolumeInfoData* other);

  // implements Message ----------------------------------------------

  VolumeInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolumeInfoData& from);
  void MergeFrom(const VolumeInfoData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 volume_id = 1;
  inline bool has_volume_id() const;
  inline void clear_volume_id();
  static const int kVolumeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 volume_id() const;
  inline void set_volume_id(::google::protobuf::uint32 value);

  // optional string device_name = 2;
  inline bool has_device_name() const;
  inline void clear_device_name();
  static const int kDeviceNameFieldNumber = 2;
  inline const ::std::string& device_name() const;
  inline void set_device_name(const ::std::string& value);
  inline void set_device_name(const char* value);
  inline void set_device_name(const char* value, size_t size);
  inline ::std::string* mutable_device_name();
  inline ::std::string* release_device_name();
  inline void set_allocated_device_name(::std::string* device_name);

  // optional uint64 logical_size = 3;
  inline bool has_logical_size() const;
  inline void clear_logical_size();
  static const int kLogicalSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 logical_size() const;
  inline void set_logical_size(::google::protobuf::uint64 value);

  // optional uint32 command_thread_count = 4;
  inline bool has_command_thread_count() const;
  inline void clear_command_thread_count();
  static const int kCommandThreadCountFieldNumber = 4;
  inline ::google::protobuf::uint32 command_thread_count() const;
  inline void set_command_thread_count(::google::protobuf::uint32 value);

  // repeated string groups = 5;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 5;
  inline const ::std::string& groups(int index) const;
  inline ::std::string* mutable_groups(int index);
  inline void set_groups(int index, const ::std::string& value);
  inline void set_groups(int index, const char* value);
  inline void set_groups(int index, const char* value, size_t size);
  inline ::std::string* add_groups();
  inline void add_groups(const ::std::string& value);
  inline void add_groups(const char* value);
  inline void add_groups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groups();

  // repeated string targets = 8;
  inline int targets_size() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 8;
  inline const ::std::string& targets(int index) const;
  inline ::std::string* mutable_targets(int index);
  inline void set_targets(int index, const ::std::string& value);
  inline void set_targets(int index, const char* value);
  inline void set_targets(int index, const char* value, size_t size);
  inline ::std::string* add_targets();
  inline void add_targets(const ::std::string& value);
  inline void add_targets(const char* value);
  inline void add_targets(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& targets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_targets();

  // optional .VolumeInfoStateData state = 6 [default = VOLUME_STATE_RUNNING];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::VolumeInfoStateData state() const;
  inline void set_state(::VolumeInfoStateData value);

  // optional uint32 sector_size = 7;
  inline bool has_sector_size() const;
  inline void clear_sector_size();
  static const int kSectorSizeFieldNumber = 7;
  inline ::google::protobuf::uint32 sector_size() const;
  inline void set_sector_size(::google::protobuf::uint32 value);

  // repeated .OptionPair chunking_options = 9;
  inline int chunking_options_size() const;
  inline void clear_chunking_options();
  static const int kChunkingOptionsFieldNumber = 9;
  inline const ::OptionPair& chunking_options(int index) const;
  inline ::OptionPair* mutable_chunking_options(int index);
  inline ::OptionPair* add_chunking_options();
  inline const ::google::protobuf::RepeatedPtrField< ::OptionPair >&
      chunking_options() const;
  inline ::google::protobuf::RepeatedPtrField< ::OptionPair >*
      mutable_chunking_options();

  // repeated .OptionPair filter_chain_options = 10;
  inline int filter_chain_options_size() const;
  inline void clear_filter_chain_options();
  static const int kFilterChainOptionsFieldNumber = 10;
  inline const ::OptionPair& filter_chain_options(int index) const;
  inline ::OptionPair* mutable_filter_chain_options(int index);
  inline ::OptionPair* add_filter_chain_options();
  inline const ::google::protobuf::RepeatedPtrField< ::OptionPair >&
      filter_chain_options() const;
  inline ::google::protobuf::RepeatedPtrField< ::OptionPair >*
      mutable_filter_chain_options();

  // @@protoc_insertion_point(class_scope:VolumeInfoData)
 private:
  inline void set_has_volume_id();
  inline void clear_has_volume_id();
  inline void set_has_device_name();
  inline void clear_has_device_name();
  inline void set_has_logical_size();
  inline void clear_has_logical_size();
  inline void set_has_command_thread_count();
  inline void clear_has_command_thread_count();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sector_size();
  inline void clear_has_sector_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_name_;
  ::google::protobuf::uint32 volume_id_;
  ::google::protobuf::uint32 command_thread_count_;
  ::google::protobuf::uint64 logical_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groups_;
  ::google::protobuf::RepeatedPtrField< ::std::string> targets_;
  int state_;
  ::google::protobuf::uint32 sector_size_;
  ::google::protobuf::RepeatedPtrField< ::OptionPair > chunking_options_;
  ::google::protobuf::RepeatedPtrField< ::OptionPair > filter_chain_options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static VolumeInfoData* default_instance_;
};
// -------------------------------------------------------------------

class ScsiResultData : public ::google::protobuf::Message {
 public:
  ScsiResultData();
  virtual ~ScsiResultData();

  ScsiResultData(const ScsiResultData& from);

  inline ScsiResultData& operator=(const ScsiResultData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScsiResultData& default_instance();

  void Swap(ScsiResultData* other);

  // implements Message ----------------------------------------------

  ScsiResultData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScsiResultData& from);
  void MergeFrom(const ScsiResultData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional uint32 sense_key = 2;
  inline bool has_sense_key() const;
  inline void clear_sense_key();
  static const int kSenseKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 sense_key() const;
  inline void set_sense_key(::google::protobuf::uint32 value);

  // optional uint32 asc = 3;
  inline bool has_asc() const;
  inline void clear_asc();
  static const int kAscFieldNumber = 3;
  inline ::google::protobuf::uint32 asc() const;
  inline void set_asc(::google::protobuf::uint32 value);

  // optional uint32 ascq = 4;
  inline bool has_ascq() const;
  inline void clear_ascq();
  static const int kAscqFieldNumber = 4;
  inline ::google::protobuf::uint32 ascq() const;
  inline void set_ascq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ScsiResultData)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_sense_key();
  inline void clear_has_sense_key();
  inline void set_has_asc();
  inline void clear_has_asc();
  inline void set_has_ascq();
  inline void clear_has_ascq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 sense_key_;
  ::google::protobuf::uint32 asc_;
  ::google::protobuf::uint32 ascq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static ScsiResultData* default_instance_;
};
// -------------------------------------------------------------------

class CommandErrorReportData : public ::google::protobuf::Message {
 public:
  CommandErrorReportData();
  virtual ~CommandErrorReportData();

  CommandErrorReportData(const CommandErrorReportData& from);

  inline CommandErrorReportData& operator=(const CommandErrorReportData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandErrorReportData& default_instance();

  void Swap(CommandErrorReportData* other);

  // implements Message ----------------------------------------------

  CommandErrorReportData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandErrorReportData& from);
  void MergeFrom(const CommandErrorReportData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 opcode = 2;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 opcode() const;
  inline void set_opcode(::google::protobuf::uint32 value);

  // optional uint64 sector = 3;
  inline bool has_sector() const;
  inline void clear_sector();
  static const int kSectorFieldNumber = 3;
  inline ::google::protobuf::uint64 sector() const;
  inline void set_sector(::google::protobuf::uint64 value);

  // optional string details = 4;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 4;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const char* value, size_t size);
  inline ::std::string* mutable_details();
  inline ::std::string* release_details();
  inline void set_allocated_details(::std::string* details);

  // optional .ScsiResultData result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline const ::ScsiResultData& result() const;
  inline ::ScsiResultData* mutable_result();
  inline ::ScsiResultData* release_result();
  inline void set_allocated_result(::ScsiResultData* result);

  // @@protoc_insertion_point(class_scope:CommandErrorReportData)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_sector();
  inline void clear_has_sector();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint64 sector_;
  ::std::string* details_;
  ::ScsiResultData* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static CommandErrorReportData* default_instance_;
};
// -------------------------------------------------------------------

class CommandErrorReportsData : public ::google::protobuf::Message {
 public:
  CommandErrorReportsData();
  virtual ~CommandErrorReportsData();

  CommandErrorReportsData(const CommandErrorReportsData& from);

  inline CommandErrorReportsData& operator=(const CommandErrorReportsData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandErrorReportsData& default_instance();

  void Swap(CommandErrorReportsData* other);

  // implements Message ----------------------------------------------

  CommandErrorReportsData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandErrorReportsData& from);
  void MergeFrom(const CommandErrorReportsData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CommandErrorReportData report = 1;
  inline int report_size() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::CommandErrorReportData& report(int index) const;
  inline ::CommandErrorReportData* mutable_report(int index);
  inline ::CommandErrorReportData* add_report();
  inline const ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData >&
      report() const;
  inline ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData >*
      mutable_report();

  // @@protoc_insertion_point(class_scope:CommandErrorReportsData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData > report_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static CommandErrorReportsData* default_instance_;
};
// -------------------------------------------------------------------

class VolumeInfoDetachingData : public ::google::protobuf::Message {
 public:
  VolumeInfoDetachingData();
  virtual ~VolumeInfoDetachingData();

  VolumeInfoDetachingData(const VolumeInfoDetachingData& from);

  inline VolumeInfoDetachingData& operator=(const VolumeInfoDetachingData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VolumeInfoDetachingData& default_instance();

  void Swap(VolumeInfoDetachingData* other);

  // implements Message ----------------------------------------------

  VolumeInfoDetachingData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolumeInfoDetachingData& from);
  void MergeFrom(const VolumeInfoDetachingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 volume_id = 1;
  inline bool has_volume_id() const;
  inline void clear_volume_id();
  static const int kVolumeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 volume_id() const;
  inline void set_volume_id(::google::protobuf::uint32 value);

  // optional string former_device_name = 2;
  inline bool has_former_device_name() const;
  inline void clear_former_device_name();
  static const int kFormerDeviceNameFieldNumber = 2;
  inline const ::std::string& former_device_name() const;
  inline void set_former_device_name(const ::std::string& value);
  inline void set_former_device_name(const char* value);
  inline void set_former_device_name(const char* value, size_t size);
  inline ::std::string* mutable_former_device_name();
  inline ::std::string* release_former_device_name();
  inline void set_allocated_former_device_name(::std::string* former_device_name);

  // optional uint64 former_logical_size = 3;
  inline bool has_former_logical_size() const;
  inline void clear_former_logical_size();
  static const int kFormerLogicalSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 former_logical_size() const;
  inline void set_former_logical_size(::google::protobuf::uint64 value);

  // optional uint64 start_block_id = 4;
  inline bool has_start_block_id() const;
  inline void clear_start_block_id();
  static const int kStartBlockIdFieldNumber = 4;
  inline ::google::protobuf::uint64 start_block_id() const;
  inline void set_start_block_id(::google::protobuf::uint64 value);

  // optional uint64 end_block_id = 5;
  inline bool has_end_block_id() const;
  inline void clear_end_block_id();
  static const int kEndBlockIdFieldNumber = 5;
  inline ::google::protobuf::uint64 end_block_id() const;
  inline void set_end_block_id(::google::protobuf::uint64 value);

  // optional uint64 current_block_id = 6;
  inline bool has_current_block_id() const;
  inline void clear_current_block_id();
  static const int kCurrentBlockIdFieldNumber = 6;
  inline ::google::protobuf::uint64 current_block_id() const;
  inline void set_current_block_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:VolumeInfoDetachingData)
 private:
  inline void set_has_volume_id();
  inline void clear_has_volume_id();
  inline void set_has_former_device_name();
  inline void clear_has_former_device_name();
  inline void set_has_former_logical_size();
  inline void clear_has_former_logical_size();
  inline void set_has_start_block_id();
  inline void clear_has_start_block_id();
  inline void set_has_end_block_id();
  inline void clear_has_end_block_id();
  inline void set_has_current_block_id();
  inline void clear_has_current_block_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* former_device_name_;
  ::google::protobuf::uint64 former_logical_size_;
  ::google::protobuf::uint64 start_block_id_;
  ::google::protobuf::uint64 end_block_id_;
  ::google::protobuf::uint64 current_block_id_;
  ::google::protobuf::uint32 volume_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static VolumeInfoDetachingData* default_instance_;
};
// -------------------------------------------------------------------

class VolumeFastCopyJobData : public ::google::protobuf::Message {
 public:
  VolumeFastCopyJobData();
  virtual ~VolumeFastCopyJobData();

  VolumeFastCopyJobData(const VolumeFastCopyJobData& from);

  inline VolumeFastCopyJobData& operator=(const VolumeFastCopyJobData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VolumeFastCopyJobData& default_instance();

  void Swap(VolumeFastCopyJobData* other);

  // implements Message ----------------------------------------------

  VolumeFastCopyJobData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolumeFastCopyJobData& from);
  void MergeFrom(const VolumeFastCopyJobData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 src_volume_id = 1;
  inline bool has_src_volume_id() const;
  inline void clear_src_volume_id();
  static const int kSrcVolumeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 src_volume_id() const;
  inline void set_src_volume_id(::google::protobuf::uint32 value);

  // required uint32 target_volume_id = 2;
  inline bool has_target_volume_id() const;
  inline void clear_target_volume_id();
  static const int kTargetVolumeIdFieldNumber = 2;
  inline ::google::protobuf::uint32 target_volume_id() const;
  inline void set_target_volume_id(::google::protobuf::uint32 value);

  // optional uint64 src_start_offset = 3;
  inline bool has_src_start_offset() const;
  inline void clear_src_start_offset();
  static const int kSrcStartOffsetFieldNumber = 3;
  inline ::google::protobuf::uint64 src_start_offset() const;
  inline void set_src_start_offset(::google::protobuf::uint64 value);

  // optional uint64 target_start_offset = 4;
  inline bool has_target_start_offset() const;
  inline void clear_target_start_offset();
  static const int kTargetStartOffsetFieldNumber = 4;
  inline ::google::protobuf::uint64 target_start_offset() const;
  inline void set_target_start_offset(::google::protobuf::uint64 value);

  // optional uint64 size = 5;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 5;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // optional uint64 current_offset = 6;
  inline bool has_current_offset() const;
  inline void clear_current_offset();
  static const int kCurrentOffsetFieldNumber = 6;
  inline ::google::protobuf::uint64 current_offset() const;
  inline void set_current_offset(::google::protobuf::uint64 value);

  // optional bool job_failed = 7;
  inline bool has_job_failed() const;
  inline void clear_job_failed();
  static const int kJobFailedFieldNumber = 7;
  inline bool job_failed() const;
  inline void set_job_failed(bool value);

  // @@protoc_insertion_point(class_scope:VolumeFastCopyJobData)
 private:
  inline void set_has_src_volume_id();
  inline void clear_has_src_volume_id();
  inline void set_has_target_volume_id();
  inline void clear_has_target_volume_id();
  inline void set_has_src_start_offset();
  inline void clear_has_src_start_offset();
  inline void set_has_target_start_offset();
  inline void clear_has_target_start_offset();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_current_offset();
  inline void clear_has_current_offset();
  inline void set_has_job_failed();
  inline void clear_has_job_failed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 src_volume_id_;
  ::google::protobuf::uint32 target_volume_id_;
  ::google::protobuf::uint64 src_start_offset_;
  ::google::protobuf::uint64 target_start_offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 current_offset_;
  bool job_failed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static VolumeFastCopyJobData* default_instance_;
};
// -------------------------------------------------------------------

class VolumeInfoFastCopyData : public ::google::protobuf::Message {
 public:
  VolumeInfoFastCopyData();
  virtual ~VolumeInfoFastCopyData();

  VolumeInfoFastCopyData(const VolumeInfoFastCopyData& from);

  inline VolumeInfoFastCopyData& operator=(const VolumeInfoFastCopyData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VolumeInfoFastCopyData& default_instance();

  void Swap(VolumeInfoFastCopyData* other);

  // implements Message ----------------------------------------------

  VolumeInfoFastCopyData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolumeInfoFastCopyData& from);
  void MergeFrom(const VolumeInfoFastCopyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .VolumeFastCopyJobData jobs = 1;
  inline int jobs_size() const;
  inline void clear_jobs();
  static const int kJobsFieldNumber = 1;
  inline const ::VolumeFastCopyJobData& jobs(int index) const;
  inline ::VolumeFastCopyJobData* mutable_jobs(int index);
  inline ::VolumeFastCopyJobData* add_jobs();
  inline const ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData >&
      jobs() const;
  inline ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData >*
      mutable_jobs();

  // @@protoc_insertion_point(class_scope:VolumeInfoFastCopyData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData > jobs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static VolumeInfoFastCopyData* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfoData : public ::google::protobuf::Message {
 public:
  GroupInfoData();
  virtual ~GroupInfoData();

  GroupInfoData(const GroupInfoData& from);

  inline GroupInfoData& operator=(const GroupInfoData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInfoData& default_instance();

  void Swap(GroupInfoData* other);

  // implements Message ----------------------------------------------

  GroupInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupInfoData& from);
  void MergeFrom(const GroupInfoData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string group_name = 1;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // repeated string initiator_pattern = 2;
  inline int initiator_pattern_size() const;
  inline void clear_initiator_pattern();
  static const int kInitiatorPatternFieldNumber = 2;
  inline const ::std::string& initiator_pattern(int index) const;
  inline ::std::string* mutable_initiator_pattern(int index);
  inline void set_initiator_pattern(int index, const ::std::string& value);
  inline void set_initiator_pattern(int index, const char* value);
  inline void set_initiator_pattern(int index, const char* value, size_t size);
  inline ::std::string* add_initiator_pattern();
  inline void add_initiator_pattern(const ::std::string& value);
  inline void add_initiator_pattern(const char* value);
  inline void add_initiator_pattern(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& initiator_pattern() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_initiator_pattern();

  // @@protoc_insertion_point(class_scope:GroupInfoData)
 private:
  inline void set_has_group_name();
  inline void clear_has_group_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* group_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> initiator_pattern_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static GroupInfoData* default_instance_;
};
// -------------------------------------------------------------------

class TargetAuthData : public ::google::protobuf::Message {
 public:
  TargetAuthData();
  virtual ~TargetAuthData();

  TargetAuthData(const TargetAuthData& from);

  inline TargetAuthData& operator=(const TargetAuthData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetAuthData& default_instance();

  void Swap(TargetAuthData* other);

  // implements Message ----------------------------------------------

  TargetAuthData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetAuthData& from);
  void MergeFrom(const TargetAuthData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string secret = 2;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 2;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const char* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:TargetAuthData)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_secret();
  inline void clear_has_secret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* secret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static TargetAuthData* default_instance_;
};
// -------------------------------------------------------------------

class TargetInfoData : public ::google::protobuf::Message {
 public:
  TargetInfoData();
  virtual ~TargetInfoData();

  TargetInfoData(const TargetInfoData& from);

  inline TargetInfoData& operator=(const TargetInfoData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetInfoData& default_instance();

  void Swap(TargetInfoData* other);

  // implements Message ----------------------------------------------

  TargetInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetInfoData& from);
  void MergeFrom(const TargetInfoData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string target_name = 1;
  inline bool has_target_name() const;
  inline void clear_target_name();
  static const int kTargetNameFieldNumber = 1;
  inline const ::std::string& target_name() const;
  inline void set_target_name(const ::std::string& value);
  inline void set_target_name(const char* value);
  inline void set_target_name(const char* value, size_t size);
  inline ::std::string* mutable_target_name();
  inline ::std::string* release_target_name();
  inline void set_allocated_target_name(::std::string* target_name);

  // optional uint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // repeated string params = 3;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::std::string& params(int index) const;
  inline ::std::string* mutable_params(int index);
  inline void set_params(int index, const ::std::string& value);
  inline void set_params(int index, const char* value);
  inline void set_params(int index, const char* value, size_t size);
  inline ::std::string* add_params();
  inline void add_params(const ::std::string& value);
  inline void add_params(const char* value);
  inline void add_params(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // optional .TargetAuthData auth = 4;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 4;
  inline const ::TargetAuthData& auth() const;
  inline ::TargetAuthData* mutable_auth();
  inline ::TargetAuthData* release_auth();
  inline void set_allocated_auth(::TargetAuthData* auth);

  // @@protoc_insertion_point(class_scope:TargetInfoData)
 private:
  inline void set_has_target_name();
  inline void clear_has_target_name();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_auth();
  inline void clear_has_auth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* target_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;
  ::TargetAuthData* auth_;
  ::google::protobuf::uint32 tid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static TargetInfoData* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoData : public ::google::protobuf::Message {
 public:
  UserInfoData();
  virtual ~UserInfoData();

  UserInfoData(const UserInfoData& from);

  inline UserInfoData& operator=(const UserInfoData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoData& default_instance();

  void Swap(UserInfoData* other);

  // implements Message ----------------------------------------------

  UserInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoData& from);
  void MergeFrom(const UserInfoData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string secret = 3;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 3;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const char* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // repeated string targets = 2;
  inline int targets_size() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 2;
  inline const ::std::string& targets(int index) const;
  inline ::std::string* mutable_targets(int index);
  inline void set_targets(int index, const ::std::string& value);
  inline void set_targets(int index, const char* value);
  inline void set_targets(int index, const char* value, size_t size);
  inline ::std::string* add_targets();
  inline void add_targets(const ::std::string& value);
  inline void add_targets(const char* value);
  inline void add_targets(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& targets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_targets();

  // optional uint32 encoding_version = 4 [default = 0];
  inline bool has_encoding_version() const;
  inline void clear_encoding_version();
  static const int kEncodingVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 encoding_version() const;
  inline void set_encoding_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserInfoData)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_secret();
  inline void clear_has_secret();
  inline void set_has_encoding_version();
  inline void clear_has_encoding_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::std::string* secret_;
  ::google::protobuf::RepeatedPtrField< ::std::string> targets_;
  ::google::protobuf::uint32 encoding_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static UserInfoData* default_instance_;
};
// -------------------------------------------------------------------

class DirtyFileData : public ::google::protobuf::Message {
 public:
  DirtyFileData();
  virtual ~DirtyFileData();

  DirtyFileData(const DirtyFileData& from);

  inline DirtyFileData& operator=(const DirtyFileData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirtyFileData& default_instance();

  void Swap(DirtyFileData* other);

  // implements Message ----------------------------------------------

  DirtyFileData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirtyFileData& from);
  void MergeFrom(const DirtyFileData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool clean = 1;
  inline bool has_clean() const;
  inline void clear_clean();
  static const int kCleanFieldNumber = 1;
  inline bool clean() const;
  inline void set_clean(bool value);

  // optional string config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // optional bool stopped = 3;
  inline bool has_stopped() const;
  inline void clear_stopped();
  static const int kStoppedFieldNumber = 3;
  inline bool stopped() const;
  inline void set_stopped(bool value);

  // optional string revision = 4;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 4;
  inline const ::std::string& revision() const;
  inline void set_revision(const ::std::string& value);
  inline void set_revision(const char* value);
  inline void set_revision(const char* value, size_t size);
  inline ::std::string* mutable_revision();
  inline ::std::string* release_revision();
  inline void set_allocated_revision(::std::string* revision);

  // @@protoc_insertion_point(class_scope:DirtyFileData)
 private:
  inline void set_has_clean();
  inline void clear_has_clean();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_stopped();
  inline void clear_has_stopped();
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* config_;
  ::std::string* revision_;
  bool clean_;
  bool stopped_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();

  void InitAsDefaultInstance();
  static DirtyFileData* default_instance_;
};
// ===================================================================


// ===================================================================

// OptionPair

// required string option_name = 1;
inline bool OptionPair::has_option_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OptionPair::set_has_option_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OptionPair::clear_has_option_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OptionPair::clear_option_name() {
  if (option_name_ != &::google::protobuf::internal::kEmptyString) {
    option_name_->clear();
  }
  clear_has_option_name();
}
inline const ::std::string& OptionPair::option_name() const {
  return *option_name_;
}
inline void OptionPair::set_option_name(const ::std::string& value) {
  set_has_option_name();
  if (option_name_ == &::google::protobuf::internal::kEmptyString) {
    option_name_ = new ::std::string;
  }
  option_name_->assign(value);
}
inline void OptionPair::set_option_name(const char* value) {
  set_has_option_name();
  if (option_name_ == &::google::protobuf::internal::kEmptyString) {
    option_name_ = new ::std::string;
  }
  option_name_->assign(value);
}
inline void OptionPair::set_option_name(const char* value, size_t size) {
  set_has_option_name();
  if (option_name_ == &::google::protobuf::internal::kEmptyString) {
    option_name_ = new ::std::string;
  }
  option_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionPair::mutable_option_name() {
  set_has_option_name();
  if (option_name_ == &::google::protobuf::internal::kEmptyString) {
    option_name_ = new ::std::string;
  }
  return option_name_;
}
inline ::std::string* OptionPair::release_option_name() {
  clear_has_option_name();
  if (option_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = option_name_;
    option_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionPair::set_allocated_option_name(::std::string* option_name) {
  if (option_name_ != &::google::protobuf::internal::kEmptyString) {
    delete option_name_;
  }
  if (option_name) {
    set_has_option_name();
    option_name_ = option_name;
  } else {
    clear_has_option_name();
    option_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string option = 2;
inline bool OptionPair::has_option() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OptionPair::set_has_option() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OptionPair::clear_has_option() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OptionPair::clear_option() {
  if (option_ != &::google::protobuf::internal::kEmptyString) {
    option_->clear();
  }
  clear_has_option();
}
inline const ::std::string& OptionPair::option() const {
  return *option_;
}
inline void OptionPair::set_option(const ::std::string& value) {
  set_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    option_ = new ::std::string;
  }
  option_->assign(value);
}
inline void OptionPair::set_option(const char* value) {
  set_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    option_ = new ::std::string;
  }
  option_->assign(value);
}
inline void OptionPair::set_option(const char* value, size_t size) {
  set_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    option_ = new ::std::string;
  }
  option_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionPair::mutable_option() {
  set_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    option_ = new ::std::string;
  }
  return option_;
}
inline ::std::string* OptionPair::release_option() {
  clear_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = option_;
    option_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionPair::set_allocated_option(::std::string* option) {
  if (option_ != &::google::protobuf::internal::kEmptyString) {
    delete option_;
  }
  if (option) {
    set_has_option();
    option_ = option;
  } else {
    clear_has_option();
    option_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VolumeInfoData

// required uint32 volume_id = 1;
inline bool VolumeInfoData::has_volume_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VolumeInfoData::set_has_volume_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VolumeInfoData::clear_has_volume_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VolumeInfoData::clear_volume_id() {
  volume_id_ = 0u;
  clear_has_volume_id();
}
inline ::google::protobuf::uint32 VolumeInfoData::volume_id() const {
  return volume_id_;
}
inline void VolumeInfoData::set_volume_id(::google::protobuf::uint32 value) {
  set_has_volume_id();
  volume_id_ = value;
}

// optional string device_name = 2;
inline bool VolumeInfoData::has_device_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VolumeInfoData::set_has_device_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VolumeInfoData::clear_has_device_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VolumeInfoData::clear_device_name() {
  if (device_name_ != &::google::protobuf::internal::kEmptyString) {
    device_name_->clear();
  }
  clear_has_device_name();
}
inline const ::std::string& VolumeInfoData::device_name() const {
  return *device_name_;
}
inline void VolumeInfoData::set_device_name(const ::std::string& value) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(value);
}
inline void VolumeInfoData::set_device_name(const char* value) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(value);
}
inline void VolumeInfoData::set_device_name(const char* value, size_t size) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VolumeInfoData::mutable_device_name() {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    device_name_ = new ::std::string;
  }
  return device_name_;
}
inline ::std::string* VolumeInfoData::release_device_name() {
  clear_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_name_;
    device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VolumeInfoData::set_allocated_device_name(::std::string* device_name) {
  if (device_name_ != &::google::protobuf::internal::kEmptyString) {
    delete device_name_;
  }
  if (device_name) {
    set_has_device_name();
    device_name_ = device_name;
  } else {
    clear_has_device_name();
    device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 logical_size = 3;
inline bool VolumeInfoData::has_logical_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VolumeInfoData::set_has_logical_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VolumeInfoData::clear_has_logical_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VolumeInfoData::clear_logical_size() {
  logical_size_ = GOOGLE_ULONGLONG(0);
  clear_has_logical_size();
}
inline ::google::protobuf::uint64 VolumeInfoData::logical_size() const {
  return logical_size_;
}
inline void VolumeInfoData::set_logical_size(::google::protobuf::uint64 value) {
  set_has_logical_size();
  logical_size_ = value;
}

// optional uint32 command_thread_count = 4;
inline bool VolumeInfoData::has_command_thread_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VolumeInfoData::set_has_command_thread_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VolumeInfoData::clear_has_command_thread_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VolumeInfoData::clear_command_thread_count() {
  command_thread_count_ = 0u;
  clear_has_command_thread_count();
}
inline ::google::protobuf::uint32 VolumeInfoData::command_thread_count() const {
  return command_thread_count_;
}
inline void VolumeInfoData::set_command_thread_count(::google::protobuf::uint32 value) {
  set_has_command_thread_count();
  command_thread_count_ = value;
}

// repeated string groups = 5;
inline int VolumeInfoData::groups_size() const {
  return groups_.size();
}
inline void VolumeInfoData::clear_groups() {
  groups_.Clear();
}
inline const ::std::string& VolumeInfoData::groups(int index) const {
  return groups_.Get(index);
}
inline ::std::string* VolumeInfoData::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline void VolumeInfoData::set_groups(int index, const ::std::string& value) {
  groups_.Mutable(index)->assign(value);
}
inline void VolumeInfoData::set_groups(int index, const char* value) {
  groups_.Mutable(index)->assign(value);
}
inline void VolumeInfoData::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VolumeInfoData::add_groups() {
  return groups_.Add();
}
inline void VolumeInfoData::add_groups(const ::std::string& value) {
  groups_.Add()->assign(value);
}
inline void VolumeInfoData::add_groups(const char* value) {
  groups_.Add()->assign(value);
}
inline void VolumeInfoData::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VolumeInfoData::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VolumeInfoData::mutable_groups() {
  return &groups_;
}

// repeated string targets = 8;
inline int VolumeInfoData::targets_size() const {
  return targets_.size();
}
inline void VolumeInfoData::clear_targets() {
  targets_.Clear();
}
inline const ::std::string& VolumeInfoData::targets(int index) const {
  return targets_.Get(index);
}
inline ::std::string* VolumeInfoData::mutable_targets(int index) {
  return targets_.Mutable(index);
}
inline void VolumeInfoData::set_targets(int index, const ::std::string& value) {
  targets_.Mutable(index)->assign(value);
}
inline void VolumeInfoData::set_targets(int index, const char* value) {
  targets_.Mutable(index)->assign(value);
}
inline void VolumeInfoData::set_targets(int index, const char* value, size_t size) {
  targets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VolumeInfoData::add_targets() {
  return targets_.Add();
}
inline void VolumeInfoData::add_targets(const ::std::string& value) {
  targets_.Add()->assign(value);
}
inline void VolumeInfoData::add_targets(const char* value) {
  targets_.Add()->assign(value);
}
inline void VolumeInfoData::add_targets(const char* value, size_t size) {
  targets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VolumeInfoData::targets() const {
  return targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VolumeInfoData::mutable_targets() {
  return &targets_;
}

// optional .VolumeInfoStateData state = 6 [default = VOLUME_STATE_RUNNING];
inline bool VolumeInfoData::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VolumeInfoData::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VolumeInfoData::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VolumeInfoData::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::VolumeInfoStateData VolumeInfoData::state() const {
  return static_cast< ::VolumeInfoStateData >(state_);
}
inline void VolumeInfoData::set_state(::VolumeInfoStateData value) {
  assert(::VolumeInfoStateData_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional uint32 sector_size = 7;
inline bool VolumeInfoData::has_sector_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VolumeInfoData::set_has_sector_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VolumeInfoData::clear_has_sector_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VolumeInfoData::clear_sector_size() {
  sector_size_ = 0u;
  clear_has_sector_size();
}
inline ::google::protobuf::uint32 VolumeInfoData::sector_size() const {
  return sector_size_;
}
inline void VolumeInfoData::set_sector_size(::google::protobuf::uint32 value) {
  set_has_sector_size();
  sector_size_ = value;
}

// repeated .OptionPair chunking_options = 9;
inline int VolumeInfoData::chunking_options_size() const {
  return chunking_options_.size();
}
inline void VolumeInfoData::clear_chunking_options() {
  chunking_options_.Clear();
}
inline const ::OptionPair& VolumeInfoData::chunking_options(int index) const {
  return chunking_options_.Get(index);
}
inline ::OptionPair* VolumeInfoData::mutable_chunking_options(int index) {
  return chunking_options_.Mutable(index);
}
inline ::OptionPair* VolumeInfoData::add_chunking_options() {
  return chunking_options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OptionPair >&
VolumeInfoData::chunking_options() const {
  return chunking_options_;
}
inline ::google::protobuf::RepeatedPtrField< ::OptionPair >*
VolumeInfoData::mutable_chunking_options() {
  return &chunking_options_;
}

// repeated .OptionPair filter_chain_options = 10;
inline int VolumeInfoData::filter_chain_options_size() const {
  return filter_chain_options_.size();
}
inline void VolumeInfoData::clear_filter_chain_options() {
  filter_chain_options_.Clear();
}
inline const ::OptionPair& VolumeInfoData::filter_chain_options(int index) const {
  return filter_chain_options_.Get(index);
}
inline ::OptionPair* VolumeInfoData::mutable_filter_chain_options(int index) {
  return filter_chain_options_.Mutable(index);
}
inline ::OptionPair* VolumeInfoData::add_filter_chain_options() {
  return filter_chain_options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OptionPair >&
VolumeInfoData::filter_chain_options() const {
  return filter_chain_options_;
}
inline ::google::protobuf::RepeatedPtrField< ::OptionPair >*
VolumeInfoData::mutable_filter_chain_options() {
  return &filter_chain_options_;
}

// -------------------------------------------------------------------

// ScsiResultData

// optional uint32 result = 1;
inline bool ScsiResultData::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScsiResultData::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScsiResultData::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScsiResultData::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 ScsiResultData::result() const {
  return result_;
}
inline void ScsiResultData::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// optional uint32 sense_key = 2;
inline bool ScsiResultData::has_sense_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScsiResultData::set_has_sense_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScsiResultData::clear_has_sense_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScsiResultData::clear_sense_key() {
  sense_key_ = 0u;
  clear_has_sense_key();
}
inline ::google::protobuf::uint32 ScsiResultData::sense_key() const {
  return sense_key_;
}
inline void ScsiResultData::set_sense_key(::google::protobuf::uint32 value) {
  set_has_sense_key();
  sense_key_ = value;
}

// optional uint32 asc = 3;
inline bool ScsiResultData::has_asc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScsiResultData::set_has_asc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScsiResultData::clear_has_asc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScsiResultData::clear_asc() {
  asc_ = 0u;
  clear_has_asc();
}
inline ::google::protobuf::uint32 ScsiResultData::asc() const {
  return asc_;
}
inline void ScsiResultData::set_asc(::google::protobuf::uint32 value) {
  set_has_asc();
  asc_ = value;
}

// optional uint32 ascq = 4;
inline bool ScsiResultData::has_ascq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScsiResultData::set_has_ascq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScsiResultData::clear_has_ascq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScsiResultData::clear_ascq() {
  ascq_ = 0u;
  clear_has_ascq();
}
inline ::google::protobuf::uint32 ScsiResultData::ascq() const {
  return ascq_;
}
inline void ScsiResultData::set_ascq(::google::protobuf::uint32 value) {
  set_has_ascq();
  ascq_ = value;
}

// -------------------------------------------------------------------

// CommandErrorReportData

// optional uint32 time = 1;
inline bool CommandErrorReportData::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandErrorReportData::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandErrorReportData::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandErrorReportData::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 CommandErrorReportData::time() const {
  return time_;
}
inline void CommandErrorReportData::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 opcode = 2;
inline bool CommandErrorReportData::has_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandErrorReportData::set_has_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandErrorReportData::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandErrorReportData::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 CommandErrorReportData::opcode() const {
  return opcode_;
}
inline void CommandErrorReportData::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
}

// optional uint64 sector = 3;
inline bool CommandErrorReportData::has_sector() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandErrorReportData::set_has_sector() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandErrorReportData::clear_has_sector() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandErrorReportData::clear_sector() {
  sector_ = GOOGLE_ULONGLONG(0);
  clear_has_sector();
}
inline ::google::protobuf::uint64 CommandErrorReportData::sector() const {
  return sector_;
}
inline void CommandErrorReportData::set_sector(::google::protobuf::uint64 value) {
  set_has_sector();
  sector_ = value;
}

// optional string details = 4;
inline bool CommandErrorReportData::has_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandErrorReportData::set_has_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandErrorReportData::clear_has_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandErrorReportData::clear_details() {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    details_->clear();
  }
  clear_has_details();
}
inline const ::std::string& CommandErrorReportData::details() const {
  return *details_;
}
inline void CommandErrorReportData::set_details(const ::std::string& value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void CommandErrorReportData::set_details(const char* value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void CommandErrorReportData::set_details(const char* value, size_t size) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandErrorReportData::mutable_details() {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  return details_;
}
inline ::std::string* CommandErrorReportData::release_details() {
  clear_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_;
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandErrorReportData::set_allocated_details(::std::string* details) {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (details) {
    set_has_details();
    details_ = details;
  } else {
    clear_has_details();
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ScsiResultData result = 5;
inline bool CommandErrorReportData::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandErrorReportData::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandErrorReportData::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandErrorReportData::clear_result() {
  if (result_ != NULL) result_->::ScsiResultData::Clear();
  clear_has_result();
}
inline const ::ScsiResultData& CommandErrorReportData::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ScsiResultData* CommandErrorReportData::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ScsiResultData;
  return result_;
}
inline ::ScsiResultData* CommandErrorReportData::release_result() {
  clear_has_result();
  ::ScsiResultData* temp = result_;
  result_ = NULL;
  return temp;
}
inline void CommandErrorReportData::set_allocated_result(::ScsiResultData* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// CommandErrorReportsData

// repeated .CommandErrorReportData report = 1;
inline int CommandErrorReportsData::report_size() const {
  return report_.size();
}
inline void CommandErrorReportsData::clear_report() {
  report_.Clear();
}
inline const ::CommandErrorReportData& CommandErrorReportsData::report(int index) const {
  return report_.Get(index);
}
inline ::CommandErrorReportData* CommandErrorReportsData::mutable_report(int index) {
  return report_.Mutable(index);
}
inline ::CommandErrorReportData* CommandErrorReportsData::add_report() {
  return report_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData >&
CommandErrorReportsData::report() const {
  return report_;
}
inline ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData >*
CommandErrorReportsData::mutable_report() {
  return &report_;
}

// -------------------------------------------------------------------

// VolumeInfoDetachingData

// required uint32 volume_id = 1;
inline bool VolumeInfoDetachingData::has_volume_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VolumeInfoDetachingData::set_has_volume_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VolumeInfoDetachingData::clear_has_volume_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VolumeInfoDetachingData::clear_volume_id() {
  volume_id_ = 0u;
  clear_has_volume_id();
}
inline ::google::protobuf::uint32 VolumeInfoDetachingData::volume_id() const {
  return volume_id_;
}
inline void VolumeInfoDetachingData::set_volume_id(::google::protobuf::uint32 value) {
  set_has_volume_id();
  volume_id_ = value;
}

// optional string former_device_name = 2;
inline bool VolumeInfoDetachingData::has_former_device_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VolumeInfoDetachingData::set_has_former_device_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VolumeInfoDetachingData::clear_has_former_device_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VolumeInfoDetachingData::clear_former_device_name() {
  if (former_device_name_ != &::google::protobuf::internal::kEmptyString) {
    former_device_name_->clear();
  }
  clear_has_former_device_name();
}
inline const ::std::string& VolumeInfoDetachingData::former_device_name() const {
  return *former_device_name_;
}
inline void VolumeInfoDetachingData::set_former_device_name(const ::std::string& value) {
  set_has_former_device_name();
  if (former_device_name_ == &::google::protobuf::internal::kEmptyString) {
    former_device_name_ = new ::std::string;
  }
  former_device_name_->assign(value);
}
inline void VolumeInfoDetachingData::set_former_device_name(const char* value) {
  set_has_former_device_name();
  if (former_device_name_ == &::google::protobuf::internal::kEmptyString) {
    former_device_name_ = new ::std::string;
  }
  former_device_name_->assign(value);
}
inline void VolumeInfoDetachingData::set_former_device_name(const char* value, size_t size) {
  set_has_former_device_name();
  if (former_device_name_ == &::google::protobuf::internal::kEmptyString) {
    former_device_name_ = new ::std::string;
  }
  former_device_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VolumeInfoDetachingData::mutable_former_device_name() {
  set_has_former_device_name();
  if (former_device_name_ == &::google::protobuf::internal::kEmptyString) {
    former_device_name_ = new ::std::string;
  }
  return former_device_name_;
}
inline ::std::string* VolumeInfoDetachingData::release_former_device_name() {
  clear_has_former_device_name();
  if (former_device_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = former_device_name_;
    former_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VolumeInfoDetachingData::set_allocated_former_device_name(::std::string* former_device_name) {
  if (former_device_name_ != &::google::protobuf::internal::kEmptyString) {
    delete former_device_name_;
  }
  if (former_device_name) {
    set_has_former_device_name();
    former_device_name_ = former_device_name;
  } else {
    clear_has_former_device_name();
    former_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 former_logical_size = 3;
inline bool VolumeInfoDetachingData::has_former_logical_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VolumeInfoDetachingData::set_has_former_logical_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VolumeInfoDetachingData::clear_has_former_logical_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VolumeInfoDetachingData::clear_former_logical_size() {
  former_logical_size_ = GOOGLE_ULONGLONG(0);
  clear_has_former_logical_size();
}
inline ::google::protobuf::uint64 VolumeInfoDetachingData::former_logical_size() const {
  return former_logical_size_;
}
inline void VolumeInfoDetachingData::set_former_logical_size(::google::protobuf::uint64 value) {
  set_has_former_logical_size();
  former_logical_size_ = value;
}

// optional uint64 start_block_id = 4;
inline bool VolumeInfoDetachingData::has_start_block_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VolumeInfoDetachingData::set_has_start_block_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VolumeInfoDetachingData::clear_has_start_block_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VolumeInfoDetachingData::clear_start_block_id() {
  start_block_id_ = GOOGLE_ULONGLONG(0);
  clear_has_start_block_id();
}
inline ::google::protobuf::uint64 VolumeInfoDetachingData::start_block_id() const {
  return start_block_id_;
}
inline void VolumeInfoDetachingData::set_start_block_id(::google::protobuf::uint64 value) {
  set_has_start_block_id();
  start_block_id_ = value;
}

// optional uint64 end_block_id = 5;
inline bool VolumeInfoDetachingData::has_end_block_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VolumeInfoDetachingData::set_has_end_block_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VolumeInfoDetachingData::clear_has_end_block_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VolumeInfoDetachingData::clear_end_block_id() {
  end_block_id_ = GOOGLE_ULONGLONG(0);
  clear_has_end_block_id();
}
inline ::google::protobuf::uint64 VolumeInfoDetachingData::end_block_id() const {
  return end_block_id_;
}
inline void VolumeInfoDetachingData::set_end_block_id(::google::protobuf::uint64 value) {
  set_has_end_block_id();
  end_block_id_ = value;
}

// optional uint64 current_block_id = 6;
inline bool VolumeInfoDetachingData::has_current_block_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VolumeInfoDetachingData::set_has_current_block_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VolumeInfoDetachingData::clear_has_current_block_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VolumeInfoDetachingData::clear_current_block_id() {
  current_block_id_ = GOOGLE_ULONGLONG(0);
  clear_has_current_block_id();
}
inline ::google::protobuf::uint64 VolumeInfoDetachingData::current_block_id() const {
  return current_block_id_;
}
inline void VolumeInfoDetachingData::set_current_block_id(::google::protobuf::uint64 value) {
  set_has_current_block_id();
  current_block_id_ = value;
}

// -------------------------------------------------------------------

// VolumeFastCopyJobData

// required uint32 src_volume_id = 1;
inline bool VolumeFastCopyJobData::has_src_volume_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VolumeFastCopyJobData::set_has_src_volume_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VolumeFastCopyJobData::clear_has_src_volume_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VolumeFastCopyJobData::clear_src_volume_id() {
  src_volume_id_ = 0u;
  clear_has_src_volume_id();
}
inline ::google::protobuf::uint32 VolumeFastCopyJobData::src_volume_id() const {
  return src_volume_id_;
}
inline void VolumeFastCopyJobData::set_src_volume_id(::google::protobuf::uint32 value) {
  set_has_src_volume_id();
  src_volume_id_ = value;
}

// required uint32 target_volume_id = 2;
inline bool VolumeFastCopyJobData::has_target_volume_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VolumeFastCopyJobData::set_has_target_volume_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VolumeFastCopyJobData::clear_has_target_volume_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VolumeFastCopyJobData::clear_target_volume_id() {
  target_volume_id_ = 0u;
  clear_has_target_volume_id();
}
inline ::google::protobuf::uint32 VolumeFastCopyJobData::target_volume_id() const {
  return target_volume_id_;
}
inline void VolumeFastCopyJobData::set_target_volume_id(::google::protobuf::uint32 value) {
  set_has_target_volume_id();
  target_volume_id_ = value;
}

// optional uint64 src_start_offset = 3;
inline bool VolumeFastCopyJobData::has_src_start_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VolumeFastCopyJobData::set_has_src_start_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VolumeFastCopyJobData::clear_has_src_start_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VolumeFastCopyJobData::clear_src_start_offset() {
  src_start_offset_ = GOOGLE_ULONGLONG(0);
  clear_has_src_start_offset();
}
inline ::google::protobuf::uint64 VolumeFastCopyJobData::src_start_offset() const {
  return src_start_offset_;
}
inline void VolumeFastCopyJobData::set_src_start_offset(::google::protobuf::uint64 value) {
  set_has_src_start_offset();
  src_start_offset_ = value;
}

// optional uint64 target_start_offset = 4;
inline bool VolumeFastCopyJobData::has_target_start_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VolumeFastCopyJobData::set_has_target_start_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VolumeFastCopyJobData::clear_has_target_start_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VolumeFastCopyJobData::clear_target_start_offset() {
  target_start_offset_ = GOOGLE_ULONGLONG(0);
  clear_has_target_start_offset();
}
inline ::google::protobuf::uint64 VolumeFastCopyJobData::target_start_offset() const {
  return target_start_offset_;
}
inline void VolumeFastCopyJobData::set_target_start_offset(::google::protobuf::uint64 value) {
  set_has_target_start_offset();
  target_start_offset_ = value;
}

// optional uint64 size = 5;
inline bool VolumeFastCopyJobData::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VolumeFastCopyJobData::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VolumeFastCopyJobData::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VolumeFastCopyJobData::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 VolumeFastCopyJobData::size() const {
  return size_;
}
inline void VolumeFastCopyJobData::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// optional uint64 current_offset = 6;
inline bool VolumeFastCopyJobData::has_current_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VolumeFastCopyJobData::set_has_current_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VolumeFastCopyJobData::clear_has_current_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VolumeFastCopyJobData::clear_current_offset() {
  current_offset_ = GOOGLE_ULONGLONG(0);
  clear_has_current_offset();
}
inline ::google::protobuf::uint64 VolumeFastCopyJobData::current_offset() const {
  return current_offset_;
}
inline void VolumeFastCopyJobData::set_current_offset(::google::protobuf::uint64 value) {
  set_has_current_offset();
  current_offset_ = value;
}

// optional bool job_failed = 7;
inline bool VolumeFastCopyJobData::has_job_failed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VolumeFastCopyJobData::set_has_job_failed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VolumeFastCopyJobData::clear_has_job_failed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VolumeFastCopyJobData::clear_job_failed() {
  job_failed_ = false;
  clear_has_job_failed();
}
inline bool VolumeFastCopyJobData::job_failed() const {
  return job_failed_;
}
inline void VolumeFastCopyJobData::set_job_failed(bool value) {
  set_has_job_failed();
  job_failed_ = value;
}

// -------------------------------------------------------------------

// VolumeInfoFastCopyData

// repeated .VolumeFastCopyJobData jobs = 1;
inline int VolumeInfoFastCopyData::jobs_size() const {
  return jobs_.size();
}
inline void VolumeInfoFastCopyData::clear_jobs() {
  jobs_.Clear();
}
inline const ::VolumeFastCopyJobData& VolumeInfoFastCopyData::jobs(int index) const {
  return jobs_.Get(index);
}
inline ::VolumeFastCopyJobData* VolumeInfoFastCopyData::mutable_jobs(int index) {
  return jobs_.Mutable(index);
}
inline ::VolumeFastCopyJobData* VolumeInfoFastCopyData::add_jobs() {
  return jobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData >&
VolumeInfoFastCopyData::jobs() const {
  return jobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData >*
VolumeInfoFastCopyData::mutable_jobs() {
  return &jobs_;
}

// -------------------------------------------------------------------

// GroupInfoData

// optional string group_name = 1;
inline bool GroupInfoData::has_group_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfoData::set_has_group_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfoData::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfoData::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupInfoData::group_name() const {
  return *group_name_;
}
inline void GroupInfoData::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupInfoData::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupInfoData::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfoData::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* GroupInfoData::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupInfoData::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string initiator_pattern = 2;
inline int GroupInfoData::initiator_pattern_size() const {
  return initiator_pattern_.size();
}
inline void GroupInfoData::clear_initiator_pattern() {
  initiator_pattern_.Clear();
}
inline const ::std::string& GroupInfoData::initiator_pattern(int index) const {
  return initiator_pattern_.Get(index);
}
inline ::std::string* GroupInfoData::mutable_initiator_pattern(int index) {
  return initiator_pattern_.Mutable(index);
}
inline void GroupInfoData::set_initiator_pattern(int index, const ::std::string& value) {
  initiator_pattern_.Mutable(index)->assign(value);
}
inline void GroupInfoData::set_initiator_pattern(int index, const char* value) {
  initiator_pattern_.Mutable(index)->assign(value);
}
inline void GroupInfoData::set_initiator_pattern(int index, const char* value, size_t size) {
  initiator_pattern_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfoData::add_initiator_pattern() {
  return initiator_pattern_.Add();
}
inline void GroupInfoData::add_initiator_pattern(const ::std::string& value) {
  initiator_pattern_.Add()->assign(value);
}
inline void GroupInfoData::add_initiator_pattern(const char* value) {
  initiator_pattern_.Add()->assign(value);
}
inline void GroupInfoData::add_initiator_pattern(const char* value, size_t size) {
  initiator_pattern_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupInfoData::initiator_pattern() const {
  return initiator_pattern_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupInfoData::mutable_initiator_pattern() {
  return &initiator_pattern_;
}

// -------------------------------------------------------------------

// TargetAuthData

// optional string username = 1;
inline bool TargetAuthData::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetAuthData::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetAuthData::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetAuthData::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& TargetAuthData::username() const {
  return *username_;
}
inline void TargetAuthData::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TargetAuthData::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TargetAuthData::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetAuthData::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* TargetAuthData::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetAuthData::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secret = 2;
inline bool TargetAuthData::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetAuthData::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetAuthData::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetAuthData::clear_secret() {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& TargetAuthData::secret() const {
  return *secret_;
}
inline void TargetAuthData::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void TargetAuthData::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void TargetAuthData::set_secret(const char* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetAuthData::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  return secret_;
}
inline ::std::string* TargetAuthData::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetAuthData::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TargetInfoData

// optional string target_name = 1;
inline bool TargetInfoData::has_target_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetInfoData::set_has_target_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetInfoData::clear_has_target_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetInfoData::clear_target_name() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    target_name_->clear();
  }
  clear_has_target_name();
}
inline const ::std::string& TargetInfoData::target_name() const {
  return *target_name_;
}
inline void TargetInfoData::set_target_name(const ::std::string& value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void TargetInfoData::set_target_name(const char* value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void TargetInfoData::set_target_name(const char* value, size_t size) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetInfoData::mutable_target_name() {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  return target_name_;
}
inline ::std::string* TargetInfoData::release_target_name() {
  clear_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_name_;
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetInfoData::set_allocated_target_name(::std::string* target_name) {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (target_name) {
    set_has_target_name();
    target_name_ = target_name;
  } else {
    clear_has_target_name();
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tid = 2;
inline bool TargetInfoData::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetInfoData::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetInfoData::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetInfoData::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 TargetInfoData::tid() const {
  return tid_;
}
inline void TargetInfoData::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// repeated string params = 3;
inline int TargetInfoData::params_size() const {
  return params_.size();
}
inline void TargetInfoData::clear_params() {
  params_.Clear();
}
inline const ::std::string& TargetInfoData::params(int index) const {
  return params_.Get(index);
}
inline ::std::string* TargetInfoData::mutable_params(int index) {
  return params_.Mutable(index);
}
inline void TargetInfoData::set_params(int index, const ::std::string& value) {
  params_.Mutable(index)->assign(value);
}
inline void TargetInfoData::set_params(int index, const char* value) {
  params_.Mutable(index)->assign(value);
}
inline void TargetInfoData::set_params(int index, const char* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetInfoData::add_params() {
  return params_.Add();
}
inline void TargetInfoData::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
}
inline void TargetInfoData::add_params(const char* value) {
  params_.Add()->assign(value);
}
inline void TargetInfoData::add_params(const char* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TargetInfoData::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TargetInfoData::mutable_params() {
  return &params_;
}

// optional .TargetAuthData auth = 4;
inline bool TargetInfoData::has_auth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TargetInfoData::set_has_auth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TargetInfoData::clear_has_auth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TargetInfoData::clear_auth() {
  if (auth_ != NULL) auth_->::TargetAuthData::Clear();
  clear_has_auth();
}
inline const ::TargetAuthData& TargetInfoData::auth() const {
  return auth_ != NULL ? *auth_ : *default_instance_->auth_;
}
inline ::TargetAuthData* TargetInfoData::mutable_auth() {
  set_has_auth();
  if (auth_ == NULL) auth_ = new ::TargetAuthData;
  return auth_;
}
inline ::TargetAuthData* TargetInfoData::release_auth() {
  clear_has_auth();
  ::TargetAuthData* temp = auth_;
  auth_ = NULL;
  return temp;
}
inline void TargetInfoData::set_allocated_auth(::TargetAuthData* auth) {
  delete auth_;
  auth_ = auth;
  if (auth) {
    set_has_auth();
  } else {
    clear_has_auth();
  }
}

// -------------------------------------------------------------------

// UserInfoData

// optional string user_name = 1;
inline bool UserInfoData::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoData::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoData::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoData::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& UserInfoData::user_name() const {
  return *user_name_;
}
inline void UserInfoData::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UserInfoData::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UserInfoData::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoData::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* UserInfoData::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoData::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secret = 3;
inline bool UserInfoData::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoData::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoData::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoData::clear_secret() {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& UserInfoData::secret() const {
  return *secret_;
}
inline void UserInfoData::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void UserInfoData::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void UserInfoData::set_secret(const char* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoData::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  return secret_;
}
inline ::std::string* UserInfoData::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoData::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string targets = 2;
inline int UserInfoData::targets_size() const {
  return targets_.size();
}
inline void UserInfoData::clear_targets() {
  targets_.Clear();
}
inline const ::std::string& UserInfoData::targets(int index) const {
  return targets_.Get(index);
}
inline ::std::string* UserInfoData::mutable_targets(int index) {
  return targets_.Mutable(index);
}
inline void UserInfoData::set_targets(int index, const ::std::string& value) {
  targets_.Mutable(index)->assign(value);
}
inline void UserInfoData::set_targets(int index, const char* value) {
  targets_.Mutable(index)->assign(value);
}
inline void UserInfoData::set_targets(int index, const char* value, size_t size) {
  targets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoData::add_targets() {
  return targets_.Add();
}
inline void UserInfoData::add_targets(const ::std::string& value) {
  targets_.Add()->assign(value);
}
inline void UserInfoData::add_targets(const char* value) {
  targets_.Add()->assign(value);
}
inline void UserInfoData::add_targets(const char* value, size_t size) {
  targets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserInfoData::targets() const {
  return targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserInfoData::mutable_targets() {
  return &targets_;
}

// optional uint32 encoding_version = 4 [default = 0];
inline bool UserInfoData::has_encoding_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoData::set_has_encoding_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoData::clear_has_encoding_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoData::clear_encoding_version() {
  encoding_version_ = 0u;
  clear_has_encoding_version();
}
inline ::google::protobuf::uint32 UserInfoData::encoding_version() const {
  return encoding_version_;
}
inline void UserInfoData::set_encoding_version(::google::protobuf::uint32 value) {
  set_has_encoding_version();
  encoding_version_ = value;
}

// -------------------------------------------------------------------

// DirtyFileData

// optional bool clean = 1;
inline bool DirtyFileData::has_clean() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirtyFileData::set_has_clean() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirtyFileData::clear_has_clean() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirtyFileData::clear_clean() {
  clean_ = false;
  clear_has_clean();
}
inline bool DirtyFileData::clean() const {
  return clean_;
}
inline void DirtyFileData::set_clean(bool value) {
  set_has_clean();
  clean_ = value;
}

// optional string config = 2;
inline bool DirtyFileData::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirtyFileData::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirtyFileData::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirtyFileData::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& DirtyFileData::config() const {
  return *config_;
}
inline void DirtyFileData::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void DirtyFileData::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void DirtyFileData::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirtyFileData::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* DirtyFileData::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirtyFileData::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool stopped = 3;
inline bool DirtyFileData::has_stopped() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirtyFileData::set_has_stopped() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirtyFileData::clear_has_stopped() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirtyFileData::clear_stopped() {
  stopped_ = false;
  clear_has_stopped();
}
inline bool DirtyFileData::stopped() const {
  return stopped_;
}
inline void DirtyFileData::set_stopped(bool value) {
  set_has_stopped();
  stopped_ = value;
}

// optional string revision = 4;
inline bool DirtyFileData::has_revision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirtyFileData::set_has_revision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirtyFileData::clear_has_revision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirtyFileData::clear_revision() {
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    revision_->clear();
  }
  clear_has_revision();
}
inline const ::std::string& DirtyFileData::revision() const {
  return *revision_;
}
inline void DirtyFileData::set_revision(const ::std::string& value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void DirtyFileData::set_revision(const char* value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void DirtyFileData::set_revision(const char* value, size_t size) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirtyFileData::mutable_revision() {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  return revision_;
}
inline ::std::string* DirtyFileData::release_revision() {
  clear_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = revision_;
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirtyFileData::set_allocated_revision(::std::string* revision) {
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    delete revision_;
  }
  if (revision) {
    set_has_revision();
    revision_ = revision;
  } else {
    clear_has_revision();
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VolumeInfoStateData>() {
  return ::VolumeInfoStateData_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dedupv1d_2eproto__INCLUDED
