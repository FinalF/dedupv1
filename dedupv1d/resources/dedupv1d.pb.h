// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dedupv1d.proto

#ifndef PROTOBUF_dedupv1d_2eproto__INCLUDED
#define PROTOBUF_dedupv1d_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dedupv1d_2eproto();
void protobuf_AssignDesc_dedupv1d_2eproto();
void protobuf_ShutdownFile_dedupv1d_2eproto();

class OptionPair;
class VolumeInfoData;
class ScsiResultData;
class CommandErrorReportData;
class CommandErrorReportsData;
class VolumeInfoDetachingData;
class VolumeFastCopyJobData;
class VolumeInfoFastCopyData;
class GroupInfoData;
class TargetAuthData;
class TargetInfoData;
class UserInfoData;
class DirtyFileData;

enum VolumeInfoStateData {
  VOLUME_STATE_RUNNING = 0,
  VOLUME_STATE_MAINTENANCE = 1
};
bool VolumeInfoStateData_IsValid(int value);
const VolumeInfoStateData VolumeInfoStateData_MIN = VOLUME_STATE_RUNNING;
const VolumeInfoStateData VolumeInfoStateData_MAX = VOLUME_STATE_MAINTENANCE;
const int VolumeInfoStateData_ARRAYSIZE = VolumeInfoStateData_MAX + 1;

const ::google::protobuf::EnumDescriptor* VolumeInfoStateData_descriptor();
inline const ::std::string& VolumeInfoStateData_Name(VolumeInfoStateData value) {
  return ::google::protobuf::internal::NameOfEnum(
    VolumeInfoStateData_descriptor(), value);
}
inline bool VolumeInfoStateData_Parse(
    const ::std::string& name, VolumeInfoStateData* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VolumeInfoStateData>(
    VolumeInfoStateData_descriptor(), name, value);
}
// ===================================================================

class OptionPair : public ::google::protobuf::Message {
 public:
  OptionPair();
  virtual ~OptionPair();
  
  OptionPair(const OptionPair& from);
  
  inline OptionPair& operator=(const OptionPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionPair& default_instance();
  
  void Swap(OptionPair* other);
  
  // implements Message ----------------------------------------------
  
  OptionPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OptionPair& from);
  void MergeFrom(const OptionPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string option_name = 1;
  inline bool has_option_name() const;
  inline void clear_option_name();
  static const int kOptionNameFieldNumber = 1;
  inline const ::std::string& option_name() const;
  inline void set_option_name(const ::std::string& value);
  inline void set_option_name(const char* value);
  inline void set_option_name(const char* value, size_t size);
  inline ::std::string* mutable_option_name();
  
  // required string option = 2;
  inline bool has_option() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 2;
  inline const ::std::string& option() const;
  inline void set_option(const ::std::string& value);
  inline void set_option(const char* value);
  inline void set_option(const char* value, size_t size);
  inline ::std::string* mutable_option();
  
  // @@protoc_insertion_point(class_scope:OptionPair)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* option_name_;
  static const ::std::string _default_option_name_;
  ::std::string* option_;
  static const ::std::string _default_option_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OptionPair* default_instance_;
};
// -------------------------------------------------------------------

class VolumeInfoData : public ::google::protobuf::Message {
 public:
  VolumeInfoData();
  virtual ~VolumeInfoData();
  
  VolumeInfoData(const VolumeInfoData& from);
  
  inline VolumeInfoData& operator=(const VolumeInfoData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VolumeInfoData& default_instance();
  
  void Swap(VolumeInfoData* other);
  
  // implements Message ----------------------------------------------
  
  VolumeInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolumeInfoData& from);
  void MergeFrom(const VolumeInfoData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 volume_id = 1;
  inline bool has_volume_id() const;
  inline void clear_volume_id();
  static const int kVolumeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 volume_id() const;
  inline void set_volume_id(::google::protobuf::uint32 value);
  
  // optional string device_name = 2;
  inline bool has_device_name() const;
  inline void clear_device_name();
  static const int kDeviceNameFieldNumber = 2;
  inline const ::std::string& device_name() const;
  inline void set_device_name(const ::std::string& value);
  inline void set_device_name(const char* value);
  inline void set_device_name(const char* value, size_t size);
  inline ::std::string* mutable_device_name();
  
  // optional uint64 logical_size = 3;
  inline bool has_logical_size() const;
  inline void clear_logical_size();
  static const int kLogicalSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 logical_size() const;
  inline void set_logical_size(::google::protobuf::uint64 value);
  
  // optional uint32 command_thread_count = 4;
  inline bool has_command_thread_count() const;
  inline void clear_command_thread_count();
  static const int kCommandThreadCountFieldNumber = 4;
  inline ::google::protobuf::uint32 command_thread_count() const;
  inline void set_command_thread_count(::google::protobuf::uint32 value);
  
  // repeated string groups = 5;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 5;
  inline const ::std::string& groups(int index) const;
  inline ::std::string* mutable_groups(int index);
  inline void set_groups(int index, const ::std::string& value);
  inline void set_groups(int index, const char* value);
  inline void set_groups(int index, const char* value, size_t size);
  inline ::std::string* add_groups();
  inline void add_groups(const ::std::string& value);
  inline void add_groups(const char* value);
  inline void add_groups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groups();
  
  // repeated string targets = 8;
  inline int targets_size() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 8;
  inline const ::std::string& targets(int index) const;
  inline ::std::string* mutable_targets(int index);
  inline void set_targets(int index, const ::std::string& value);
  inline void set_targets(int index, const char* value);
  inline void set_targets(int index, const char* value, size_t size);
  inline ::std::string* add_targets();
  inline void add_targets(const ::std::string& value);
  inline void add_targets(const char* value);
  inline void add_targets(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& targets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_targets();
  
  // optional .VolumeInfoStateData state = 6 [default = VOLUME_STATE_RUNNING];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline VolumeInfoStateData state() const;
  inline void set_state(VolumeInfoStateData value);
  
  // optional uint32 sector_size = 7;
  inline bool has_sector_size() const;
  inline void clear_sector_size();
  static const int kSectorSizeFieldNumber = 7;
  inline ::google::protobuf::uint32 sector_size() const;
  inline void set_sector_size(::google::protobuf::uint32 value);
  
  // repeated .OptionPair chunking_options = 9;
  inline int chunking_options_size() const;
  inline void clear_chunking_options();
  static const int kChunkingOptionsFieldNumber = 9;
  inline const ::OptionPair& chunking_options(int index) const;
  inline ::OptionPair* mutable_chunking_options(int index);
  inline ::OptionPair* add_chunking_options();
  inline const ::google::protobuf::RepeatedPtrField< ::OptionPair >&
      chunking_options() const;
  inline ::google::protobuf::RepeatedPtrField< ::OptionPair >*
      mutable_chunking_options();
  
  // repeated .OptionPair filter_chain_options = 10;
  inline int filter_chain_options_size() const;
  inline void clear_filter_chain_options();
  static const int kFilterChainOptionsFieldNumber = 10;
  inline const ::OptionPair& filter_chain_options(int index) const;
  inline ::OptionPair* mutable_filter_chain_options(int index);
  inline ::OptionPair* add_filter_chain_options();
  inline const ::google::protobuf::RepeatedPtrField< ::OptionPair >&
      filter_chain_options() const;
  inline ::google::protobuf::RepeatedPtrField< ::OptionPair >*
      mutable_filter_chain_options();
  
  // @@protoc_insertion_point(class_scope:VolumeInfoData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 volume_id_;
  ::std::string* device_name_;
  static const ::std::string _default_device_name_;
  ::google::protobuf::uint64 logical_size_;
  ::google::protobuf::uint32 command_thread_count_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groups_;
  ::google::protobuf::RepeatedPtrField< ::std::string> targets_;
  int state_;
  ::google::protobuf::uint32 sector_size_;
  ::google::protobuf::RepeatedPtrField< ::OptionPair > chunking_options_;
  ::google::protobuf::RepeatedPtrField< ::OptionPair > filter_chain_options_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VolumeInfoData* default_instance_;
};
// -------------------------------------------------------------------

class ScsiResultData : public ::google::protobuf::Message {
 public:
  ScsiResultData();
  virtual ~ScsiResultData();
  
  ScsiResultData(const ScsiResultData& from);
  
  inline ScsiResultData& operator=(const ScsiResultData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScsiResultData& default_instance();
  
  void Swap(ScsiResultData* other);
  
  // implements Message ----------------------------------------------
  
  ScsiResultData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScsiResultData& from);
  void MergeFrom(const ScsiResultData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional uint32 sense_key = 2;
  inline bool has_sense_key() const;
  inline void clear_sense_key();
  static const int kSenseKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 sense_key() const;
  inline void set_sense_key(::google::protobuf::uint32 value);
  
  // optional uint32 asc = 3;
  inline bool has_asc() const;
  inline void clear_asc();
  static const int kAscFieldNumber = 3;
  inline ::google::protobuf::uint32 asc() const;
  inline void set_asc(::google::protobuf::uint32 value);
  
  // optional uint32 ascq = 4;
  inline bool has_ascq() const;
  inline void clear_ascq();
  static const int kAscqFieldNumber = 4;
  inline ::google::protobuf::uint32 ascq() const;
  inline void set_ascq(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ScsiResultData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 sense_key_;
  ::google::protobuf::uint32 asc_;
  ::google::protobuf::uint32 ascq_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ScsiResultData* default_instance_;
};
// -------------------------------------------------------------------

class CommandErrorReportData : public ::google::protobuf::Message {
 public:
  CommandErrorReportData();
  virtual ~CommandErrorReportData();
  
  CommandErrorReportData(const CommandErrorReportData& from);
  
  inline CommandErrorReportData& operator=(const CommandErrorReportData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandErrorReportData& default_instance();
  
  void Swap(CommandErrorReportData* other);
  
  // implements Message ----------------------------------------------
  
  CommandErrorReportData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandErrorReportData& from);
  void MergeFrom(const CommandErrorReportData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);
  
  // optional uint32 opcode = 2;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 opcode() const;
  inline void set_opcode(::google::protobuf::uint32 value);
  
  // optional uint64 sector = 3;
  inline bool has_sector() const;
  inline void clear_sector();
  static const int kSectorFieldNumber = 3;
  inline ::google::protobuf::uint64 sector() const;
  inline void set_sector(::google::protobuf::uint64 value);
  
  // optional string details = 4;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 4;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const char* value, size_t size);
  inline ::std::string* mutable_details();
  
  // optional .ScsiResultData result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline const ::ScsiResultData& result() const;
  inline ::ScsiResultData* mutable_result();
  
  // @@protoc_insertion_point(class_scope:CommandErrorReportData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint64 sector_;
  ::std::string* details_;
  static const ::std::string _default_details_;
  ::ScsiResultData* result_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CommandErrorReportData* default_instance_;
};
// -------------------------------------------------------------------

class CommandErrorReportsData : public ::google::protobuf::Message {
 public:
  CommandErrorReportsData();
  virtual ~CommandErrorReportsData();
  
  CommandErrorReportsData(const CommandErrorReportsData& from);
  
  inline CommandErrorReportsData& operator=(const CommandErrorReportsData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandErrorReportsData& default_instance();
  
  void Swap(CommandErrorReportsData* other);
  
  // implements Message ----------------------------------------------
  
  CommandErrorReportsData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandErrorReportsData& from);
  void MergeFrom(const CommandErrorReportsData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .CommandErrorReportData report = 1;
  inline int report_size() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::CommandErrorReportData& report(int index) const;
  inline ::CommandErrorReportData* mutable_report(int index);
  inline ::CommandErrorReportData* add_report();
  inline const ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData >&
      report() const;
  inline ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData >*
      mutable_report();
  
  // @@protoc_insertion_point(class_scope:CommandErrorReportsData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData > report_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CommandErrorReportsData* default_instance_;
};
// -------------------------------------------------------------------

class VolumeInfoDetachingData : public ::google::protobuf::Message {
 public:
  VolumeInfoDetachingData();
  virtual ~VolumeInfoDetachingData();
  
  VolumeInfoDetachingData(const VolumeInfoDetachingData& from);
  
  inline VolumeInfoDetachingData& operator=(const VolumeInfoDetachingData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VolumeInfoDetachingData& default_instance();
  
  void Swap(VolumeInfoDetachingData* other);
  
  // implements Message ----------------------------------------------
  
  VolumeInfoDetachingData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolumeInfoDetachingData& from);
  void MergeFrom(const VolumeInfoDetachingData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 volume_id = 1;
  inline bool has_volume_id() const;
  inline void clear_volume_id();
  static const int kVolumeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 volume_id() const;
  inline void set_volume_id(::google::protobuf::uint32 value);
  
  // optional string former_device_name = 2;
  inline bool has_former_device_name() const;
  inline void clear_former_device_name();
  static const int kFormerDeviceNameFieldNumber = 2;
  inline const ::std::string& former_device_name() const;
  inline void set_former_device_name(const ::std::string& value);
  inline void set_former_device_name(const char* value);
  inline void set_former_device_name(const char* value, size_t size);
  inline ::std::string* mutable_former_device_name();
  
  // optional uint64 former_logical_size = 3;
  inline bool has_former_logical_size() const;
  inline void clear_former_logical_size();
  static const int kFormerLogicalSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 former_logical_size() const;
  inline void set_former_logical_size(::google::protobuf::uint64 value);
  
  // optional uint64 start_block_id = 4;
  inline bool has_start_block_id() const;
  inline void clear_start_block_id();
  static const int kStartBlockIdFieldNumber = 4;
  inline ::google::protobuf::uint64 start_block_id() const;
  inline void set_start_block_id(::google::protobuf::uint64 value);
  
  // optional uint64 end_block_id = 5;
  inline bool has_end_block_id() const;
  inline void clear_end_block_id();
  static const int kEndBlockIdFieldNumber = 5;
  inline ::google::protobuf::uint64 end_block_id() const;
  inline void set_end_block_id(::google::protobuf::uint64 value);
  
  // optional uint64 current_block_id = 6;
  inline bool has_current_block_id() const;
  inline void clear_current_block_id();
  static const int kCurrentBlockIdFieldNumber = 6;
  inline ::google::protobuf::uint64 current_block_id() const;
  inline void set_current_block_id(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:VolumeInfoDetachingData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 volume_id_;
  ::std::string* former_device_name_;
  static const ::std::string _default_former_device_name_;
  ::google::protobuf::uint64 former_logical_size_;
  ::google::protobuf::uint64 start_block_id_;
  ::google::protobuf::uint64 end_block_id_;
  ::google::protobuf::uint64 current_block_id_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VolumeInfoDetachingData* default_instance_;
};
// -------------------------------------------------------------------

class VolumeFastCopyJobData : public ::google::protobuf::Message {
 public:
  VolumeFastCopyJobData();
  virtual ~VolumeFastCopyJobData();
  
  VolumeFastCopyJobData(const VolumeFastCopyJobData& from);
  
  inline VolumeFastCopyJobData& operator=(const VolumeFastCopyJobData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VolumeFastCopyJobData& default_instance();
  
  void Swap(VolumeFastCopyJobData* other);
  
  // implements Message ----------------------------------------------
  
  VolumeFastCopyJobData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolumeFastCopyJobData& from);
  void MergeFrom(const VolumeFastCopyJobData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 src_volume_id = 1;
  inline bool has_src_volume_id() const;
  inline void clear_src_volume_id();
  static const int kSrcVolumeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 src_volume_id() const;
  inline void set_src_volume_id(::google::protobuf::uint32 value);
  
  // required uint32 target_volume_id = 2;
  inline bool has_target_volume_id() const;
  inline void clear_target_volume_id();
  static const int kTargetVolumeIdFieldNumber = 2;
  inline ::google::protobuf::uint32 target_volume_id() const;
  inline void set_target_volume_id(::google::protobuf::uint32 value);
  
  // optional uint64 src_start_offset = 3;
  inline bool has_src_start_offset() const;
  inline void clear_src_start_offset();
  static const int kSrcStartOffsetFieldNumber = 3;
  inline ::google::protobuf::uint64 src_start_offset() const;
  inline void set_src_start_offset(::google::protobuf::uint64 value);
  
  // optional uint64 target_start_offset = 4;
  inline bool has_target_start_offset() const;
  inline void clear_target_start_offset();
  static const int kTargetStartOffsetFieldNumber = 4;
  inline ::google::protobuf::uint64 target_start_offset() const;
  inline void set_target_start_offset(::google::protobuf::uint64 value);
  
  // optional uint64 size = 5;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 5;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // optional uint64 current_offset = 6;
  inline bool has_current_offset() const;
  inline void clear_current_offset();
  static const int kCurrentOffsetFieldNumber = 6;
  inline ::google::protobuf::uint64 current_offset() const;
  inline void set_current_offset(::google::protobuf::uint64 value);
  
  // optional bool job_failed = 7;
  inline bool has_job_failed() const;
  inline void clear_job_failed();
  static const int kJobFailedFieldNumber = 7;
  inline bool job_failed() const;
  inline void set_job_failed(bool value);
  
  // @@protoc_insertion_point(class_scope:VolumeFastCopyJobData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 src_volume_id_;
  ::google::protobuf::uint32 target_volume_id_;
  ::google::protobuf::uint64 src_start_offset_;
  ::google::protobuf::uint64 target_start_offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 current_offset_;
  bool job_failed_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VolumeFastCopyJobData* default_instance_;
};
// -------------------------------------------------------------------

class VolumeInfoFastCopyData : public ::google::protobuf::Message {
 public:
  VolumeInfoFastCopyData();
  virtual ~VolumeInfoFastCopyData();
  
  VolumeInfoFastCopyData(const VolumeInfoFastCopyData& from);
  
  inline VolumeInfoFastCopyData& operator=(const VolumeInfoFastCopyData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VolumeInfoFastCopyData& default_instance();
  
  void Swap(VolumeInfoFastCopyData* other);
  
  // implements Message ----------------------------------------------
  
  VolumeInfoFastCopyData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolumeInfoFastCopyData& from);
  void MergeFrom(const VolumeInfoFastCopyData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .VolumeFastCopyJobData jobs = 1;
  inline int jobs_size() const;
  inline void clear_jobs();
  static const int kJobsFieldNumber = 1;
  inline const ::VolumeFastCopyJobData& jobs(int index) const;
  inline ::VolumeFastCopyJobData* mutable_jobs(int index);
  inline ::VolumeFastCopyJobData* add_jobs();
  inline const ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData >&
      jobs() const;
  inline ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData >*
      mutable_jobs();
  
  // @@protoc_insertion_point(class_scope:VolumeInfoFastCopyData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData > jobs_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VolumeInfoFastCopyData* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfoData : public ::google::protobuf::Message {
 public:
  GroupInfoData();
  virtual ~GroupInfoData();
  
  GroupInfoData(const GroupInfoData& from);
  
  inline GroupInfoData& operator=(const GroupInfoData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInfoData& default_instance();
  
  void Swap(GroupInfoData* other);
  
  // implements Message ----------------------------------------------
  
  GroupInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupInfoData& from);
  void MergeFrom(const GroupInfoData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string group_name = 1;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  
  // repeated string initiator_pattern = 2;
  inline int initiator_pattern_size() const;
  inline void clear_initiator_pattern();
  static const int kInitiatorPatternFieldNumber = 2;
  inline const ::std::string& initiator_pattern(int index) const;
  inline ::std::string* mutable_initiator_pattern(int index);
  inline void set_initiator_pattern(int index, const ::std::string& value);
  inline void set_initiator_pattern(int index, const char* value);
  inline void set_initiator_pattern(int index, const char* value, size_t size);
  inline ::std::string* add_initiator_pattern();
  inline void add_initiator_pattern(const ::std::string& value);
  inline void add_initiator_pattern(const char* value);
  inline void add_initiator_pattern(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& initiator_pattern() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_initiator_pattern();
  
  // @@protoc_insertion_point(class_scope:GroupInfoData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* group_name_;
  static const ::std::string _default_group_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> initiator_pattern_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GroupInfoData* default_instance_;
};
// -------------------------------------------------------------------

class TargetAuthData : public ::google::protobuf::Message {
 public:
  TargetAuthData();
  virtual ~TargetAuthData();
  
  TargetAuthData(const TargetAuthData& from);
  
  inline TargetAuthData& operator=(const TargetAuthData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetAuthData& default_instance();
  
  void Swap(TargetAuthData* other);
  
  // implements Message ----------------------------------------------
  
  TargetAuthData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetAuthData& from);
  void MergeFrom(const TargetAuthData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  
  // optional string secret = 2;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 2;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const char* value, size_t size);
  inline ::std::string* mutable_secret();
  
  // @@protoc_insertion_point(class_scope:TargetAuthData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* username_;
  static const ::std::string _default_username_;
  ::std::string* secret_;
  static const ::std::string _default_secret_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TargetAuthData* default_instance_;
};
// -------------------------------------------------------------------

class TargetInfoData : public ::google::protobuf::Message {
 public:
  TargetInfoData();
  virtual ~TargetInfoData();
  
  TargetInfoData(const TargetInfoData& from);
  
  inline TargetInfoData& operator=(const TargetInfoData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetInfoData& default_instance();
  
  void Swap(TargetInfoData* other);
  
  // implements Message ----------------------------------------------
  
  TargetInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetInfoData& from);
  void MergeFrom(const TargetInfoData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string target_name = 1;
  inline bool has_target_name() const;
  inline void clear_target_name();
  static const int kTargetNameFieldNumber = 1;
  inline const ::std::string& target_name() const;
  inline void set_target_name(const ::std::string& value);
  inline void set_target_name(const char* value);
  inline void set_target_name(const char* value, size_t size);
  inline ::std::string* mutable_target_name();
  
  // optional uint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);
  
  // repeated string params = 3;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::std::string& params(int index) const;
  inline ::std::string* mutable_params(int index);
  inline void set_params(int index, const ::std::string& value);
  inline void set_params(int index, const char* value);
  inline void set_params(int index, const char* value, size_t size);
  inline ::std::string* add_params();
  inline void add_params(const ::std::string& value);
  inline void add_params(const char* value);
  inline void add_params(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();
  
  // optional .TargetAuthData auth = 4;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 4;
  inline const ::TargetAuthData& auth() const;
  inline ::TargetAuthData* mutable_auth();
  
  // @@protoc_insertion_point(class_scope:TargetInfoData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* target_name_;
  static const ::std::string _default_target_name_;
  ::google::protobuf::uint32 tid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;
  ::TargetAuthData* auth_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TargetInfoData* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoData : public ::google::protobuf::Message {
 public:
  UserInfoData();
  virtual ~UserInfoData();
  
  UserInfoData(const UserInfoData& from);
  
  inline UserInfoData& operator=(const UserInfoData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoData& default_instance();
  
  void Swap(UserInfoData* other);
  
  // implements Message ----------------------------------------------
  
  UserInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoData& from);
  void MergeFrom(const UserInfoData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  
  // optional string secret = 3;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 3;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const char* value, size_t size);
  inline ::std::string* mutable_secret();
  
  // repeated string targets = 2;
  inline int targets_size() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 2;
  inline const ::std::string& targets(int index) const;
  inline ::std::string* mutable_targets(int index);
  inline void set_targets(int index, const ::std::string& value);
  inline void set_targets(int index, const char* value);
  inline void set_targets(int index, const char* value, size_t size);
  inline ::std::string* add_targets();
  inline void add_targets(const ::std::string& value);
  inline void add_targets(const char* value);
  inline void add_targets(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& targets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_targets();
  
  // optional uint32 encoding_version = 4 [default = 0];
  inline bool has_encoding_version() const;
  inline void clear_encoding_version();
  static const int kEncodingVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 encoding_version() const;
  inline void set_encoding_version(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:UserInfoData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* user_name_;
  static const ::std::string _default_user_name_;
  ::std::string* secret_;
  static const ::std::string _default_secret_;
  ::google::protobuf::RepeatedPtrField< ::std::string> targets_;
  ::google::protobuf::uint32 encoding_version_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserInfoData* default_instance_;
};
// -------------------------------------------------------------------

class DirtyFileData : public ::google::protobuf::Message {
 public:
  DirtyFileData();
  virtual ~DirtyFileData();
  
  DirtyFileData(const DirtyFileData& from);
  
  inline DirtyFileData& operator=(const DirtyFileData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DirtyFileData& default_instance();
  
  void Swap(DirtyFileData* other);
  
  // implements Message ----------------------------------------------
  
  DirtyFileData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirtyFileData& from);
  void MergeFrom(const DirtyFileData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool clean = 1;
  inline bool has_clean() const;
  inline void clear_clean();
  static const int kCleanFieldNumber = 1;
  inline bool clean() const;
  inline void set_clean(bool value);
  
  // optional string config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  
  // optional bool stopped = 3;
  inline bool has_stopped() const;
  inline void clear_stopped();
  static const int kStoppedFieldNumber = 3;
  inline bool stopped() const;
  inline void set_stopped(bool value);
  
  // optional string revision = 4;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 4;
  inline const ::std::string& revision() const;
  inline void set_revision(const ::std::string& value);
  inline void set_revision(const char* value);
  inline void set_revision(const char* value, size_t size);
  inline ::std::string* mutable_revision();
  
  // @@protoc_insertion_point(class_scope:DirtyFileData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool clean_;
  ::std::string* config_;
  static const ::std::string _default_config_;
  bool stopped_;
  ::std::string* revision_;
  static const ::std::string _default_revision_;
  friend void  protobuf_AddDesc_dedupv1d_2eproto();
  friend void protobuf_AssignDesc_dedupv1d_2eproto();
  friend void protobuf_ShutdownFile_dedupv1d_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DirtyFileData* default_instance_;
};
// ===================================================================


// ===================================================================

// OptionPair

// required string option_name = 1;
inline bool OptionPair::has_option_name() const {
  return _has_bit(0);
}
inline void OptionPair::clear_option_name() {
  if (option_name_ != &_default_option_name_) {
    option_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OptionPair::option_name() const {
  return *option_name_;
}
inline void OptionPair::set_option_name(const ::std::string& value) {
  _set_bit(0);
  if (option_name_ == &_default_option_name_) {
    option_name_ = new ::std::string;
  }
  option_name_->assign(value);
}
inline void OptionPair::set_option_name(const char* value) {
  _set_bit(0);
  if (option_name_ == &_default_option_name_) {
    option_name_ = new ::std::string;
  }
  option_name_->assign(value);
}
inline void OptionPair::set_option_name(const char* value, size_t size) {
  _set_bit(0);
  if (option_name_ == &_default_option_name_) {
    option_name_ = new ::std::string;
  }
  option_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionPair::mutable_option_name() {
  _set_bit(0);
  if (option_name_ == &_default_option_name_) {
    option_name_ = new ::std::string;
  }
  return option_name_;
}

// required string option = 2;
inline bool OptionPair::has_option() const {
  return _has_bit(1);
}
inline void OptionPair::clear_option() {
  if (option_ != &_default_option_) {
    option_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OptionPair::option() const {
  return *option_;
}
inline void OptionPair::set_option(const ::std::string& value) {
  _set_bit(1);
  if (option_ == &_default_option_) {
    option_ = new ::std::string;
  }
  option_->assign(value);
}
inline void OptionPair::set_option(const char* value) {
  _set_bit(1);
  if (option_ == &_default_option_) {
    option_ = new ::std::string;
  }
  option_->assign(value);
}
inline void OptionPair::set_option(const char* value, size_t size) {
  _set_bit(1);
  if (option_ == &_default_option_) {
    option_ = new ::std::string;
  }
  option_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionPair::mutable_option() {
  _set_bit(1);
  if (option_ == &_default_option_) {
    option_ = new ::std::string;
  }
  return option_;
}

// -------------------------------------------------------------------

// VolumeInfoData

// required uint32 volume_id = 1;
inline bool VolumeInfoData::has_volume_id() const {
  return _has_bit(0);
}
inline void VolumeInfoData::clear_volume_id() {
  volume_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 VolumeInfoData::volume_id() const {
  return volume_id_;
}
inline void VolumeInfoData::set_volume_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  volume_id_ = value;
}

// optional string device_name = 2;
inline bool VolumeInfoData::has_device_name() const {
  return _has_bit(1);
}
inline void VolumeInfoData::clear_device_name() {
  if (device_name_ != &_default_device_name_) {
    device_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& VolumeInfoData::device_name() const {
  return *device_name_;
}
inline void VolumeInfoData::set_device_name(const ::std::string& value) {
  _set_bit(1);
  if (device_name_ == &_default_device_name_) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(value);
}
inline void VolumeInfoData::set_device_name(const char* value) {
  _set_bit(1);
  if (device_name_ == &_default_device_name_) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(value);
}
inline void VolumeInfoData::set_device_name(const char* value, size_t size) {
  _set_bit(1);
  if (device_name_ == &_default_device_name_) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VolumeInfoData::mutable_device_name() {
  _set_bit(1);
  if (device_name_ == &_default_device_name_) {
    device_name_ = new ::std::string;
  }
  return device_name_;
}

// optional uint64 logical_size = 3;
inline bool VolumeInfoData::has_logical_size() const {
  return _has_bit(2);
}
inline void VolumeInfoData::clear_logical_size() {
  logical_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 VolumeInfoData::logical_size() const {
  return logical_size_;
}
inline void VolumeInfoData::set_logical_size(::google::protobuf::uint64 value) {
  _set_bit(2);
  logical_size_ = value;
}

// optional uint32 command_thread_count = 4;
inline bool VolumeInfoData::has_command_thread_count() const {
  return _has_bit(3);
}
inline void VolumeInfoData::clear_command_thread_count() {
  command_thread_count_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 VolumeInfoData::command_thread_count() const {
  return command_thread_count_;
}
inline void VolumeInfoData::set_command_thread_count(::google::protobuf::uint32 value) {
  _set_bit(3);
  command_thread_count_ = value;
}

// repeated string groups = 5;
inline int VolumeInfoData::groups_size() const {
  return groups_.size();
}
inline void VolumeInfoData::clear_groups() {
  groups_.Clear();
}
inline const ::std::string& VolumeInfoData::groups(int index) const {
  return groups_.Get(index);
}
inline ::std::string* VolumeInfoData::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline void VolumeInfoData::set_groups(int index, const ::std::string& value) {
  groups_.Mutable(index)->assign(value);
}
inline void VolumeInfoData::set_groups(int index, const char* value) {
  groups_.Mutable(index)->assign(value);
}
inline void VolumeInfoData::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VolumeInfoData::add_groups() {
  return groups_.Add();
}
inline void VolumeInfoData::add_groups(const ::std::string& value) {
  groups_.Add()->assign(value);
}
inline void VolumeInfoData::add_groups(const char* value) {
  groups_.Add()->assign(value);
}
inline void VolumeInfoData::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VolumeInfoData::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VolumeInfoData::mutable_groups() {
  return &groups_;
}

// repeated string targets = 8;
inline int VolumeInfoData::targets_size() const {
  return targets_.size();
}
inline void VolumeInfoData::clear_targets() {
  targets_.Clear();
}
inline const ::std::string& VolumeInfoData::targets(int index) const {
  return targets_.Get(index);
}
inline ::std::string* VolumeInfoData::mutable_targets(int index) {
  return targets_.Mutable(index);
}
inline void VolumeInfoData::set_targets(int index, const ::std::string& value) {
  targets_.Mutable(index)->assign(value);
}
inline void VolumeInfoData::set_targets(int index, const char* value) {
  targets_.Mutable(index)->assign(value);
}
inline void VolumeInfoData::set_targets(int index, const char* value, size_t size) {
  targets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VolumeInfoData::add_targets() {
  return targets_.Add();
}
inline void VolumeInfoData::add_targets(const ::std::string& value) {
  targets_.Add()->assign(value);
}
inline void VolumeInfoData::add_targets(const char* value) {
  targets_.Add()->assign(value);
}
inline void VolumeInfoData::add_targets(const char* value, size_t size) {
  targets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VolumeInfoData::targets() const {
  return targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VolumeInfoData::mutable_targets() {
  return &targets_;
}

// optional .VolumeInfoStateData state = 6 [default = VOLUME_STATE_RUNNING];
inline bool VolumeInfoData::has_state() const {
  return _has_bit(6);
}
inline void VolumeInfoData::clear_state() {
  state_ = 0;
  _clear_bit(6);
}
inline VolumeInfoStateData VolumeInfoData::state() const {
  return static_cast< VolumeInfoStateData >(state_);
}
inline void VolumeInfoData::set_state(VolumeInfoStateData value) {
  GOOGLE_DCHECK(VolumeInfoStateData_IsValid(value));
  _set_bit(6);
  state_ = value;
}

// optional uint32 sector_size = 7;
inline bool VolumeInfoData::has_sector_size() const {
  return _has_bit(7);
}
inline void VolumeInfoData::clear_sector_size() {
  sector_size_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 VolumeInfoData::sector_size() const {
  return sector_size_;
}
inline void VolumeInfoData::set_sector_size(::google::protobuf::uint32 value) {
  _set_bit(7);
  sector_size_ = value;
}

// repeated .OptionPair chunking_options = 9;
inline int VolumeInfoData::chunking_options_size() const {
  return chunking_options_.size();
}
inline void VolumeInfoData::clear_chunking_options() {
  chunking_options_.Clear();
}
inline const ::OptionPair& VolumeInfoData::chunking_options(int index) const {
  return chunking_options_.Get(index);
}
inline ::OptionPair* VolumeInfoData::mutable_chunking_options(int index) {
  return chunking_options_.Mutable(index);
}
inline ::OptionPair* VolumeInfoData::add_chunking_options() {
  return chunking_options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OptionPair >&
VolumeInfoData::chunking_options() const {
  return chunking_options_;
}
inline ::google::protobuf::RepeatedPtrField< ::OptionPair >*
VolumeInfoData::mutable_chunking_options() {
  return &chunking_options_;
}

// repeated .OptionPair filter_chain_options = 10;
inline int VolumeInfoData::filter_chain_options_size() const {
  return filter_chain_options_.size();
}
inline void VolumeInfoData::clear_filter_chain_options() {
  filter_chain_options_.Clear();
}
inline const ::OptionPair& VolumeInfoData::filter_chain_options(int index) const {
  return filter_chain_options_.Get(index);
}
inline ::OptionPair* VolumeInfoData::mutable_filter_chain_options(int index) {
  return filter_chain_options_.Mutable(index);
}
inline ::OptionPair* VolumeInfoData::add_filter_chain_options() {
  return filter_chain_options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OptionPair >&
VolumeInfoData::filter_chain_options() const {
  return filter_chain_options_;
}
inline ::google::protobuf::RepeatedPtrField< ::OptionPair >*
VolumeInfoData::mutable_filter_chain_options() {
  return &filter_chain_options_;
}

// -------------------------------------------------------------------

// ScsiResultData

// optional uint32 result = 1;
inline bool ScsiResultData::has_result() const {
  return _has_bit(0);
}
inline void ScsiResultData::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ScsiResultData::result() const {
  return result_;
}
inline void ScsiResultData::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional uint32 sense_key = 2;
inline bool ScsiResultData::has_sense_key() const {
  return _has_bit(1);
}
inline void ScsiResultData::clear_sense_key() {
  sense_key_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 ScsiResultData::sense_key() const {
  return sense_key_;
}
inline void ScsiResultData::set_sense_key(::google::protobuf::uint32 value) {
  _set_bit(1);
  sense_key_ = value;
}

// optional uint32 asc = 3;
inline bool ScsiResultData::has_asc() const {
  return _has_bit(2);
}
inline void ScsiResultData::clear_asc() {
  asc_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 ScsiResultData::asc() const {
  return asc_;
}
inline void ScsiResultData::set_asc(::google::protobuf::uint32 value) {
  _set_bit(2);
  asc_ = value;
}

// optional uint32 ascq = 4;
inline bool ScsiResultData::has_ascq() const {
  return _has_bit(3);
}
inline void ScsiResultData::clear_ascq() {
  ascq_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 ScsiResultData::ascq() const {
  return ascq_;
}
inline void ScsiResultData::set_ascq(::google::protobuf::uint32 value) {
  _set_bit(3);
  ascq_ = value;
}

// -------------------------------------------------------------------

// CommandErrorReportData

// optional uint32 time = 1;
inline bool CommandErrorReportData::has_time() const {
  return _has_bit(0);
}
inline void CommandErrorReportData::clear_time() {
  time_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CommandErrorReportData::time() const {
  return time_;
}
inline void CommandErrorReportData::set_time(::google::protobuf::uint32 value) {
  _set_bit(0);
  time_ = value;
}

// optional uint32 opcode = 2;
inline bool CommandErrorReportData::has_opcode() const {
  return _has_bit(1);
}
inline void CommandErrorReportData::clear_opcode() {
  opcode_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 CommandErrorReportData::opcode() const {
  return opcode_;
}
inline void CommandErrorReportData::set_opcode(::google::protobuf::uint32 value) {
  _set_bit(1);
  opcode_ = value;
}

// optional uint64 sector = 3;
inline bool CommandErrorReportData::has_sector() const {
  return _has_bit(2);
}
inline void CommandErrorReportData::clear_sector() {
  sector_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 CommandErrorReportData::sector() const {
  return sector_;
}
inline void CommandErrorReportData::set_sector(::google::protobuf::uint64 value) {
  _set_bit(2);
  sector_ = value;
}

// optional string details = 4;
inline bool CommandErrorReportData::has_details() const {
  return _has_bit(3);
}
inline void CommandErrorReportData::clear_details() {
  if (details_ != &_default_details_) {
    details_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& CommandErrorReportData::details() const {
  return *details_;
}
inline void CommandErrorReportData::set_details(const ::std::string& value) {
  _set_bit(3);
  if (details_ == &_default_details_) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void CommandErrorReportData::set_details(const char* value) {
  _set_bit(3);
  if (details_ == &_default_details_) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void CommandErrorReportData::set_details(const char* value, size_t size) {
  _set_bit(3);
  if (details_ == &_default_details_) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandErrorReportData::mutable_details() {
  _set_bit(3);
  if (details_ == &_default_details_) {
    details_ = new ::std::string;
  }
  return details_;
}

// optional .ScsiResultData result = 5;
inline bool CommandErrorReportData::has_result() const {
  return _has_bit(4);
}
inline void CommandErrorReportData::clear_result() {
  if (result_ != NULL) result_->::ScsiResultData::Clear();
  _clear_bit(4);
}
inline const ::ScsiResultData& CommandErrorReportData::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ScsiResultData* CommandErrorReportData::mutable_result() {
  _set_bit(4);
  if (result_ == NULL) result_ = new ::ScsiResultData;
  return result_;
}

// -------------------------------------------------------------------

// CommandErrorReportsData

// repeated .CommandErrorReportData report = 1;
inline int CommandErrorReportsData::report_size() const {
  return report_.size();
}
inline void CommandErrorReportsData::clear_report() {
  report_.Clear();
}
inline const ::CommandErrorReportData& CommandErrorReportsData::report(int index) const {
  return report_.Get(index);
}
inline ::CommandErrorReportData* CommandErrorReportsData::mutable_report(int index) {
  return report_.Mutable(index);
}
inline ::CommandErrorReportData* CommandErrorReportsData::add_report() {
  return report_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData >&
CommandErrorReportsData::report() const {
  return report_;
}
inline ::google::protobuf::RepeatedPtrField< ::CommandErrorReportData >*
CommandErrorReportsData::mutable_report() {
  return &report_;
}

// -------------------------------------------------------------------

// VolumeInfoDetachingData

// required uint32 volume_id = 1;
inline bool VolumeInfoDetachingData::has_volume_id() const {
  return _has_bit(0);
}
inline void VolumeInfoDetachingData::clear_volume_id() {
  volume_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 VolumeInfoDetachingData::volume_id() const {
  return volume_id_;
}
inline void VolumeInfoDetachingData::set_volume_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  volume_id_ = value;
}

// optional string former_device_name = 2;
inline bool VolumeInfoDetachingData::has_former_device_name() const {
  return _has_bit(1);
}
inline void VolumeInfoDetachingData::clear_former_device_name() {
  if (former_device_name_ != &_default_former_device_name_) {
    former_device_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& VolumeInfoDetachingData::former_device_name() const {
  return *former_device_name_;
}
inline void VolumeInfoDetachingData::set_former_device_name(const ::std::string& value) {
  _set_bit(1);
  if (former_device_name_ == &_default_former_device_name_) {
    former_device_name_ = new ::std::string;
  }
  former_device_name_->assign(value);
}
inline void VolumeInfoDetachingData::set_former_device_name(const char* value) {
  _set_bit(1);
  if (former_device_name_ == &_default_former_device_name_) {
    former_device_name_ = new ::std::string;
  }
  former_device_name_->assign(value);
}
inline void VolumeInfoDetachingData::set_former_device_name(const char* value, size_t size) {
  _set_bit(1);
  if (former_device_name_ == &_default_former_device_name_) {
    former_device_name_ = new ::std::string;
  }
  former_device_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VolumeInfoDetachingData::mutable_former_device_name() {
  _set_bit(1);
  if (former_device_name_ == &_default_former_device_name_) {
    former_device_name_ = new ::std::string;
  }
  return former_device_name_;
}

// optional uint64 former_logical_size = 3;
inline bool VolumeInfoDetachingData::has_former_logical_size() const {
  return _has_bit(2);
}
inline void VolumeInfoDetachingData::clear_former_logical_size() {
  former_logical_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 VolumeInfoDetachingData::former_logical_size() const {
  return former_logical_size_;
}
inline void VolumeInfoDetachingData::set_former_logical_size(::google::protobuf::uint64 value) {
  _set_bit(2);
  former_logical_size_ = value;
}

// optional uint64 start_block_id = 4;
inline bool VolumeInfoDetachingData::has_start_block_id() const {
  return _has_bit(3);
}
inline void VolumeInfoDetachingData::clear_start_block_id() {
  start_block_id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 VolumeInfoDetachingData::start_block_id() const {
  return start_block_id_;
}
inline void VolumeInfoDetachingData::set_start_block_id(::google::protobuf::uint64 value) {
  _set_bit(3);
  start_block_id_ = value;
}

// optional uint64 end_block_id = 5;
inline bool VolumeInfoDetachingData::has_end_block_id() const {
  return _has_bit(4);
}
inline void VolumeInfoDetachingData::clear_end_block_id() {
  end_block_id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 VolumeInfoDetachingData::end_block_id() const {
  return end_block_id_;
}
inline void VolumeInfoDetachingData::set_end_block_id(::google::protobuf::uint64 value) {
  _set_bit(4);
  end_block_id_ = value;
}

// optional uint64 current_block_id = 6;
inline bool VolumeInfoDetachingData::has_current_block_id() const {
  return _has_bit(5);
}
inline void VolumeInfoDetachingData::clear_current_block_id() {
  current_block_id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 VolumeInfoDetachingData::current_block_id() const {
  return current_block_id_;
}
inline void VolumeInfoDetachingData::set_current_block_id(::google::protobuf::uint64 value) {
  _set_bit(5);
  current_block_id_ = value;
}

// -------------------------------------------------------------------

// VolumeFastCopyJobData

// required uint32 src_volume_id = 1;
inline bool VolumeFastCopyJobData::has_src_volume_id() const {
  return _has_bit(0);
}
inline void VolumeFastCopyJobData::clear_src_volume_id() {
  src_volume_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 VolumeFastCopyJobData::src_volume_id() const {
  return src_volume_id_;
}
inline void VolumeFastCopyJobData::set_src_volume_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  src_volume_id_ = value;
}

// required uint32 target_volume_id = 2;
inline bool VolumeFastCopyJobData::has_target_volume_id() const {
  return _has_bit(1);
}
inline void VolumeFastCopyJobData::clear_target_volume_id() {
  target_volume_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 VolumeFastCopyJobData::target_volume_id() const {
  return target_volume_id_;
}
inline void VolumeFastCopyJobData::set_target_volume_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  target_volume_id_ = value;
}

// optional uint64 src_start_offset = 3;
inline bool VolumeFastCopyJobData::has_src_start_offset() const {
  return _has_bit(2);
}
inline void VolumeFastCopyJobData::clear_src_start_offset() {
  src_start_offset_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 VolumeFastCopyJobData::src_start_offset() const {
  return src_start_offset_;
}
inline void VolumeFastCopyJobData::set_src_start_offset(::google::protobuf::uint64 value) {
  _set_bit(2);
  src_start_offset_ = value;
}

// optional uint64 target_start_offset = 4;
inline bool VolumeFastCopyJobData::has_target_start_offset() const {
  return _has_bit(3);
}
inline void VolumeFastCopyJobData::clear_target_start_offset() {
  target_start_offset_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 VolumeFastCopyJobData::target_start_offset() const {
  return target_start_offset_;
}
inline void VolumeFastCopyJobData::set_target_start_offset(::google::protobuf::uint64 value) {
  _set_bit(3);
  target_start_offset_ = value;
}

// optional uint64 size = 5;
inline bool VolumeFastCopyJobData::has_size() const {
  return _has_bit(4);
}
inline void VolumeFastCopyJobData::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 VolumeFastCopyJobData::size() const {
  return size_;
}
inline void VolumeFastCopyJobData::set_size(::google::protobuf::uint64 value) {
  _set_bit(4);
  size_ = value;
}

// optional uint64 current_offset = 6;
inline bool VolumeFastCopyJobData::has_current_offset() const {
  return _has_bit(5);
}
inline void VolumeFastCopyJobData::clear_current_offset() {
  current_offset_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 VolumeFastCopyJobData::current_offset() const {
  return current_offset_;
}
inline void VolumeFastCopyJobData::set_current_offset(::google::protobuf::uint64 value) {
  _set_bit(5);
  current_offset_ = value;
}

// optional bool job_failed = 7;
inline bool VolumeFastCopyJobData::has_job_failed() const {
  return _has_bit(6);
}
inline void VolumeFastCopyJobData::clear_job_failed() {
  job_failed_ = false;
  _clear_bit(6);
}
inline bool VolumeFastCopyJobData::job_failed() const {
  return job_failed_;
}
inline void VolumeFastCopyJobData::set_job_failed(bool value) {
  _set_bit(6);
  job_failed_ = value;
}

// -------------------------------------------------------------------

// VolumeInfoFastCopyData

// repeated .VolumeFastCopyJobData jobs = 1;
inline int VolumeInfoFastCopyData::jobs_size() const {
  return jobs_.size();
}
inline void VolumeInfoFastCopyData::clear_jobs() {
  jobs_.Clear();
}
inline const ::VolumeFastCopyJobData& VolumeInfoFastCopyData::jobs(int index) const {
  return jobs_.Get(index);
}
inline ::VolumeFastCopyJobData* VolumeInfoFastCopyData::mutable_jobs(int index) {
  return jobs_.Mutable(index);
}
inline ::VolumeFastCopyJobData* VolumeInfoFastCopyData::add_jobs() {
  return jobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData >&
VolumeInfoFastCopyData::jobs() const {
  return jobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::VolumeFastCopyJobData >*
VolumeInfoFastCopyData::mutable_jobs() {
  return &jobs_;
}

// -------------------------------------------------------------------

// GroupInfoData

// optional string group_name = 1;
inline bool GroupInfoData::has_group_name() const {
  return _has_bit(0);
}
inline void GroupInfoData::clear_group_name() {
  if (group_name_ != &_default_group_name_) {
    group_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GroupInfoData::group_name() const {
  return *group_name_;
}
inline void GroupInfoData::set_group_name(const ::std::string& value) {
  _set_bit(0);
  if (group_name_ == &_default_group_name_) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupInfoData::set_group_name(const char* value) {
  _set_bit(0);
  if (group_name_ == &_default_group_name_) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupInfoData::set_group_name(const char* value, size_t size) {
  _set_bit(0);
  if (group_name_ == &_default_group_name_) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfoData::mutable_group_name() {
  _set_bit(0);
  if (group_name_ == &_default_group_name_) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}

// repeated string initiator_pattern = 2;
inline int GroupInfoData::initiator_pattern_size() const {
  return initiator_pattern_.size();
}
inline void GroupInfoData::clear_initiator_pattern() {
  initiator_pattern_.Clear();
}
inline const ::std::string& GroupInfoData::initiator_pattern(int index) const {
  return initiator_pattern_.Get(index);
}
inline ::std::string* GroupInfoData::mutable_initiator_pattern(int index) {
  return initiator_pattern_.Mutable(index);
}
inline void GroupInfoData::set_initiator_pattern(int index, const ::std::string& value) {
  initiator_pattern_.Mutable(index)->assign(value);
}
inline void GroupInfoData::set_initiator_pattern(int index, const char* value) {
  initiator_pattern_.Mutable(index)->assign(value);
}
inline void GroupInfoData::set_initiator_pattern(int index, const char* value, size_t size) {
  initiator_pattern_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfoData::add_initiator_pattern() {
  return initiator_pattern_.Add();
}
inline void GroupInfoData::add_initiator_pattern(const ::std::string& value) {
  initiator_pattern_.Add()->assign(value);
}
inline void GroupInfoData::add_initiator_pattern(const char* value) {
  initiator_pattern_.Add()->assign(value);
}
inline void GroupInfoData::add_initiator_pattern(const char* value, size_t size) {
  initiator_pattern_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupInfoData::initiator_pattern() const {
  return initiator_pattern_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupInfoData::mutable_initiator_pattern() {
  return &initiator_pattern_;
}

// -------------------------------------------------------------------

// TargetAuthData

// optional string username = 1;
inline bool TargetAuthData::has_username() const {
  return _has_bit(0);
}
inline void TargetAuthData::clear_username() {
  if (username_ != &_default_username_) {
    username_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TargetAuthData::username() const {
  return *username_;
}
inline void TargetAuthData::set_username(const ::std::string& value) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TargetAuthData::set_username(const char* value) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void TargetAuthData::set_username(const char* value, size_t size) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetAuthData::mutable_username() {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  return username_;
}

// optional string secret = 2;
inline bool TargetAuthData::has_secret() const {
  return _has_bit(1);
}
inline void TargetAuthData::clear_secret() {
  if (secret_ != &_default_secret_) {
    secret_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& TargetAuthData::secret() const {
  return *secret_;
}
inline void TargetAuthData::set_secret(const ::std::string& value) {
  _set_bit(1);
  if (secret_ == &_default_secret_) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void TargetAuthData::set_secret(const char* value) {
  _set_bit(1);
  if (secret_ == &_default_secret_) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void TargetAuthData::set_secret(const char* value, size_t size) {
  _set_bit(1);
  if (secret_ == &_default_secret_) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetAuthData::mutable_secret() {
  _set_bit(1);
  if (secret_ == &_default_secret_) {
    secret_ = new ::std::string;
  }
  return secret_;
}

// -------------------------------------------------------------------

// TargetInfoData

// optional string target_name = 1;
inline bool TargetInfoData::has_target_name() const {
  return _has_bit(0);
}
inline void TargetInfoData::clear_target_name() {
  if (target_name_ != &_default_target_name_) {
    target_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TargetInfoData::target_name() const {
  return *target_name_;
}
inline void TargetInfoData::set_target_name(const ::std::string& value) {
  _set_bit(0);
  if (target_name_ == &_default_target_name_) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void TargetInfoData::set_target_name(const char* value) {
  _set_bit(0);
  if (target_name_ == &_default_target_name_) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void TargetInfoData::set_target_name(const char* value, size_t size) {
  _set_bit(0);
  if (target_name_ == &_default_target_name_) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetInfoData::mutable_target_name() {
  _set_bit(0);
  if (target_name_ == &_default_target_name_) {
    target_name_ = new ::std::string;
  }
  return target_name_;
}

// optional uint32 tid = 2;
inline bool TargetInfoData::has_tid() const {
  return _has_bit(1);
}
inline void TargetInfoData::clear_tid() {
  tid_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 TargetInfoData::tid() const {
  return tid_;
}
inline void TargetInfoData::set_tid(::google::protobuf::uint32 value) {
  _set_bit(1);
  tid_ = value;
}

// repeated string params = 3;
inline int TargetInfoData::params_size() const {
  return params_.size();
}
inline void TargetInfoData::clear_params() {
  params_.Clear();
}
inline const ::std::string& TargetInfoData::params(int index) const {
  return params_.Get(index);
}
inline ::std::string* TargetInfoData::mutable_params(int index) {
  return params_.Mutable(index);
}
inline void TargetInfoData::set_params(int index, const ::std::string& value) {
  params_.Mutable(index)->assign(value);
}
inline void TargetInfoData::set_params(int index, const char* value) {
  params_.Mutable(index)->assign(value);
}
inline void TargetInfoData::set_params(int index, const char* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetInfoData::add_params() {
  return params_.Add();
}
inline void TargetInfoData::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
}
inline void TargetInfoData::add_params(const char* value) {
  params_.Add()->assign(value);
}
inline void TargetInfoData::add_params(const char* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TargetInfoData::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TargetInfoData::mutable_params() {
  return &params_;
}

// optional .TargetAuthData auth = 4;
inline bool TargetInfoData::has_auth() const {
  return _has_bit(3);
}
inline void TargetInfoData::clear_auth() {
  if (auth_ != NULL) auth_->::TargetAuthData::Clear();
  _clear_bit(3);
}
inline const ::TargetAuthData& TargetInfoData::auth() const {
  return auth_ != NULL ? *auth_ : *default_instance_->auth_;
}
inline ::TargetAuthData* TargetInfoData::mutable_auth() {
  _set_bit(3);
  if (auth_ == NULL) auth_ = new ::TargetAuthData;
  return auth_;
}

// -------------------------------------------------------------------

// UserInfoData

// optional string user_name = 1;
inline bool UserInfoData::has_user_name() const {
  return _has_bit(0);
}
inline void UserInfoData::clear_user_name() {
  if (user_name_ != &_default_user_name_) {
    user_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& UserInfoData::user_name() const {
  return *user_name_;
}
inline void UserInfoData::set_user_name(const ::std::string& value) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UserInfoData::set_user_name(const char* value) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UserInfoData::set_user_name(const char* value, size_t size) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoData::mutable_user_name() {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}

// optional string secret = 3;
inline bool UserInfoData::has_secret() const {
  return _has_bit(1);
}
inline void UserInfoData::clear_secret() {
  if (secret_ != &_default_secret_) {
    secret_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UserInfoData::secret() const {
  return *secret_;
}
inline void UserInfoData::set_secret(const ::std::string& value) {
  _set_bit(1);
  if (secret_ == &_default_secret_) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void UserInfoData::set_secret(const char* value) {
  _set_bit(1);
  if (secret_ == &_default_secret_) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void UserInfoData::set_secret(const char* value, size_t size) {
  _set_bit(1);
  if (secret_ == &_default_secret_) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoData::mutable_secret() {
  _set_bit(1);
  if (secret_ == &_default_secret_) {
    secret_ = new ::std::string;
  }
  return secret_;
}

// repeated string targets = 2;
inline int UserInfoData::targets_size() const {
  return targets_.size();
}
inline void UserInfoData::clear_targets() {
  targets_.Clear();
}
inline const ::std::string& UserInfoData::targets(int index) const {
  return targets_.Get(index);
}
inline ::std::string* UserInfoData::mutable_targets(int index) {
  return targets_.Mutable(index);
}
inline void UserInfoData::set_targets(int index, const ::std::string& value) {
  targets_.Mutable(index)->assign(value);
}
inline void UserInfoData::set_targets(int index, const char* value) {
  targets_.Mutable(index)->assign(value);
}
inline void UserInfoData::set_targets(int index, const char* value, size_t size) {
  targets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoData::add_targets() {
  return targets_.Add();
}
inline void UserInfoData::add_targets(const ::std::string& value) {
  targets_.Add()->assign(value);
}
inline void UserInfoData::add_targets(const char* value) {
  targets_.Add()->assign(value);
}
inline void UserInfoData::add_targets(const char* value, size_t size) {
  targets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserInfoData::targets() const {
  return targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserInfoData::mutable_targets() {
  return &targets_;
}

// optional uint32 encoding_version = 4 [default = 0];
inline bool UserInfoData::has_encoding_version() const {
  return _has_bit(3);
}
inline void UserInfoData::clear_encoding_version() {
  encoding_version_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 UserInfoData::encoding_version() const {
  return encoding_version_;
}
inline void UserInfoData::set_encoding_version(::google::protobuf::uint32 value) {
  _set_bit(3);
  encoding_version_ = value;
}

// -------------------------------------------------------------------

// DirtyFileData

// optional bool clean = 1;
inline bool DirtyFileData::has_clean() const {
  return _has_bit(0);
}
inline void DirtyFileData::clear_clean() {
  clean_ = false;
  _clear_bit(0);
}
inline bool DirtyFileData::clean() const {
  return clean_;
}
inline void DirtyFileData::set_clean(bool value) {
  _set_bit(0);
  clean_ = value;
}

// optional string config = 2;
inline bool DirtyFileData::has_config() const {
  return _has_bit(1);
}
inline void DirtyFileData::clear_config() {
  if (config_ != &_default_config_) {
    config_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DirtyFileData::config() const {
  return *config_;
}
inline void DirtyFileData::set_config(const ::std::string& value) {
  _set_bit(1);
  if (config_ == &_default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void DirtyFileData::set_config(const char* value) {
  _set_bit(1);
  if (config_ == &_default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void DirtyFileData::set_config(const char* value, size_t size) {
  _set_bit(1);
  if (config_ == &_default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirtyFileData::mutable_config() {
  _set_bit(1);
  if (config_ == &_default_config_) {
    config_ = new ::std::string;
  }
  return config_;
}

// optional bool stopped = 3;
inline bool DirtyFileData::has_stopped() const {
  return _has_bit(2);
}
inline void DirtyFileData::clear_stopped() {
  stopped_ = false;
  _clear_bit(2);
}
inline bool DirtyFileData::stopped() const {
  return stopped_;
}
inline void DirtyFileData::set_stopped(bool value) {
  _set_bit(2);
  stopped_ = value;
}

// optional string revision = 4;
inline bool DirtyFileData::has_revision() const {
  return _has_bit(3);
}
inline void DirtyFileData::clear_revision() {
  if (revision_ != &_default_revision_) {
    revision_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& DirtyFileData::revision() const {
  return *revision_;
}
inline void DirtyFileData::set_revision(const ::std::string& value) {
  _set_bit(3);
  if (revision_ == &_default_revision_) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void DirtyFileData::set_revision(const char* value) {
  _set_bit(3);
  if (revision_ == &_default_revision_) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void DirtyFileData::set_revision(const char* value, size_t size) {
  _set_bit(3);
  if (revision_ == &_default_revision_) {
    revision_ = new ::std::string;
  }
  revision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirtyFileData::mutable_revision() {
  _set_bit(3);
  if (revision_ == &_default_revision_) {
    revision_ = new ::std::string;
  }
  return revision_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< VolumeInfoStateData>() {
  return VolumeInfoStateData_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dedupv1d_2eproto__INCLUDED
