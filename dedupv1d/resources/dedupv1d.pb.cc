// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dedupv1d.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "dedupv1d.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* OptionPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OptionPair_reflection_ = NULL;
const ::google::protobuf::Descriptor* VolumeInfoData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VolumeInfoData_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScsiResultData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScsiResultData_reflection_ = NULL;
const ::google::protobuf::Descriptor* CommandErrorReportData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CommandErrorReportData_reflection_ = NULL;
const ::google::protobuf::Descriptor* CommandErrorReportsData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CommandErrorReportsData_reflection_ = NULL;
const ::google::protobuf::Descriptor* VolumeInfoDetachingData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VolumeInfoDetachingData_reflection_ = NULL;
const ::google::protobuf::Descriptor* VolumeFastCopyJobData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VolumeFastCopyJobData_reflection_ = NULL;
const ::google::protobuf::Descriptor* VolumeInfoFastCopyData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VolumeInfoFastCopyData_reflection_ = NULL;
const ::google::protobuf::Descriptor* GroupInfoData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GroupInfoData_reflection_ = NULL;
const ::google::protobuf::Descriptor* TargetAuthData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TargetAuthData_reflection_ = NULL;
const ::google::protobuf::Descriptor* TargetInfoData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TargetInfoData_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserInfoData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserInfoData_reflection_ = NULL;
const ::google::protobuf::Descriptor* DirtyFileData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DirtyFileData_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* VolumeInfoStateData_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_dedupv1d_2eproto() {
  protobuf_AddDesc_dedupv1d_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "dedupv1d.proto");
  GOOGLE_CHECK(file != NULL);
  OptionPair_descriptor_ = file->message_type(0);
  static const int OptionPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OptionPair, option_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OptionPair, option_),
  };
  OptionPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OptionPair_descriptor_,
      OptionPair::default_instance_,
      OptionPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OptionPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OptionPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OptionPair));
  VolumeInfoData_descriptor_ = file->message_type(1);
  static const int VolumeInfoData_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, volume_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, device_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, logical_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, command_thread_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, groups_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, targets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, sector_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, chunking_options_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, filter_chain_options_),
  };
  VolumeInfoData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VolumeInfoData_descriptor_,
      VolumeInfoData::default_instance_,
      VolumeInfoData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VolumeInfoData));
  ScsiResultData_descriptor_ = file->message_type(2);
  static const int ScsiResultData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScsiResultData, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScsiResultData, sense_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScsiResultData, asc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScsiResultData, ascq_),
  };
  ScsiResultData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ScsiResultData_descriptor_,
      ScsiResultData::default_instance_,
      ScsiResultData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScsiResultData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScsiResultData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ScsiResultData));
  CommandErrorReportData_descriptor_ = file->message_type(3);
  static const int CommandErrorReportData_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportData, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportData, opcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportData, sector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportData, details_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportData, result_),
  };
  CommandErrorReportData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CommandErrorReportData_descriptor_,
      CommandErrorReportData::default_instance_,
      CommandErrorReportData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CommandErrorReportData));
  CommandErrorReportsData_descriptor_ = file->message_type(4);
  static const int CommandErrorReportsData_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportsData, report_),
  };
  CommandErrorReportsData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CommandErrorReportsData_descriptor_,
      CommandErrorReportsData::default_instance_,
      CommandErrorReportsData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportsData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandErrorReportsData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CommandErrorReportsData));
  VolumeInfoDetachingData_descriptor_ = file->message_type(5);
  static const int VolumeInfoDetachingData_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoDetachingData, volume_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoDetachingData, former_device_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoDetachingData, former_logical_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoDetachingData, start_block_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoDetachingData, end_block_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoDetachingData, current_block_id_),
  };
  VolumeInfoDetachingData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VolumeInfoDetachingData_descriptor_,
      VolumeInfoDetachingData::default_instance_,
      VolumeInfoDetachingData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoDetachingData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoDetachingData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VolumeInfoDetachingData));
  VolumeFastCopyJobData_descriptor_ = file->message_type(6);
  static const int VolumeFastCopyJobData_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, src_volume_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, target_volume_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, src_start_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, target_start_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, current_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, job_failed_),
  };
  VolumeFastCopyJobData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VolumeFastCopyJobData_descriptor_,
      VolumeFastCopyJobData::default_instance_,
      VolumeFastCopyJobData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeFastCopyJobData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VolumeFastCopyJobData));
  VolumeInfoFastCopyData_descriptor_ = file->message_type(7);
  static const int VolumeInfoFastCopyData_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoFastCopyData, jobs_),
  };
  VolumeInfoFastCopyData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VolumeInfoFastCopyData_descriptor_,
      VolumeInfoFastCopyData::default_instance_,
      VolumeInfoFastCopyData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoFastCopyData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VolumeInfoFastCopyData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VolumeInfoFastCopyData));
  GroupInfoData_descriptor_ = file->message_type(8);
  static const int GroupInfoData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GroupInfoData, group_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GroupInfoData, initiator_pattern_),
  };
  GroupInfoData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GroupInfoData_descriptor_,
      GroupInfoData::default_instance_,
      GroupInfoData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GroupInfoData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GroupInfoData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GroupInfoData));
  TargetAuthData_descriptor_ = file->message_type(9);
  static const int TargetAuthData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetAuthData, username_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetAuthData, secret_),
  };
  TargetAuthData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TargetAuthData_descriptor_,
      TargetAuthData::default_instance_,
      TargetAuthData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetAuthData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetAuthData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TargetAuthData));
  TargetInfoData_descriptor_ = file->message_type(10);
  static const int TargetInfoData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetInfoData, target_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetInfoData, tid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetInfoData, params_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetInfoData, auth_),
  };
  TargetInfoData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TargetInfoData_descriptor_,
      TargetInfoData::default_instance_,
      TargetInfoData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetInfoData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetInfoData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TargetInfoData));
  UserInfoData_descriptor_ = file->message_type(11);
  static const int UserInfoData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserInfoData, user_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserInfoData, secret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserInfoData, targets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserInfoData, encoding_version_),
  };
  UserInfoData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserInfoData_descriptor_,
      UserInfoData::default_instance_,
      UserInfoData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserInfoData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserInfoData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserInfoData));
  DirtyFileData_descriptor_ = file->message_type(12);
  static const int DirtyFileData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirtyFileData, clean_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirtyFileData, config_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirtyFileData, stopped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirtyFileData, revision_),
  };
  DirtyFileData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DirtyFileData_descriptor_,
      DirtyFileData::default_instance_,
      DirtyFileData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirtyFileData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirtyFileData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DirtyFileData));
  VolumeInfoStateData_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_dedupv1d_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OptionPair_descriptor_, &OptionPair::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VolumeInfoData_descriptor_, &VolumeInfoData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ScsiResultData_descriptor_, &ScsiResultData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CommandErrorReportData_descriptor_, &CommandErrorReportData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CommandErrorReportsData_descriptor_, &CommandErrorReportsData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VolumeInfoDetachingData_descriptor_, &VolumeInfoDetachingData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VolumeFastCopyJobData_descriptor_, &VolumeFastCopyJobData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VolumeInfoFastCopyData_descriptor_, &VolumeInfoFastCopyData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GroupInfoData_descriptor_, &GroupInfoData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TargetAuthData_descriptor_, &TargetAuthData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TargetInfoData_descriptor_, &TargetInfoData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserInfoData_descriptor_, &UserInfoData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DirtyFileData_descriptor_, &DirtyFileData::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_dedupv1d_2eproto() {
  delete OptionPair::default_instance_;
  delete OptionPair_reflection_;
  delete VolumeInfoData::default_instance_;
  delete VolumeInfoData_reflection_;
  delete ScsiResultData::default_instance_;
  delete ScsiResultData_reflection_;
  delete CommandErrorReportData::default_instance_;
  delete CommandErrorReportData_reflection_;
  delete CommandErrorReportsData::default_instance_;
  delete CommandErrorReportsData_reflection_;
  delete VolumeInfoDetachingData::default_instance_;
  delete VolumeInfoDetachingData_reflection_;
  delete VolumeFastCopyJobData::default_instance_;
  delete VolumeFastCopyJobData_reflection_;
  delete VolumeInfoFastCopyData::default_instance_;
  delete VolumeInfoFastCopyData_reflection_;
  delete GroupInfoData::default_instance_;
  delete GroupInfoData_reflection_;
  delete TargetAuthData::default_instance_;
  delete TargetAuthData_reflection_;
  delete TargetInfoData::default_instance_;
  delete TargetInfoData_reflection_;
  delete UserInfoData::default_instance_;
  delete UserInfoData_reflection_;
  delete DirtyFileData::default_instance_;
  delete DirtyFileData_reflection_;
}

void protobuf_AddDesc_dedupv1d_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016dedupv1d.proto\"1\n\nOptionPair\022\023\n\013option"
    "_name\030\001 \002(\t\022\016\n\006option\030\002 \002(\t\"\257\002\n\016VolumeIn"
    "foData\022\021\n\tvolume_id\030\001 \002(\r\022\023\n\013device_name"
    "\030\002 \001(\t\022\024\n\014logical_size\030\003 \001(\004\022\034\n\024command_"
    "thread_count\030\004 \001(\r\022\016\n\006groups\030\005 \003(\t\022\017\n\007ta"
    "rgets\030\010 \003(\t\0229\n\005state\030\006 \001(\0162\024.VolumeInfoS"
    "tateData:\024VOLUME_STATE_RUNNING\022\023\n\013sector"
    "_size\030\007 \001(\r\022%\n\020chunking_options\030\t \003(\0132\013."
    "OptionPair\022)\n\024filter_chain_options\030\n \003(\013"
    "2\013.OptionPair\"N\n\016ScsiResultData\022\016\n\006resul"
    "t\030\001 \001(\r\022\021\n\tsense_key\030\002 \001(\r\022\013\n\003asc\030\003 \001(\r\022"
    "\014\n\004ascq\030\004 \001(\r\"x\n\026CommandErrorReportData\022"
    "\014\n\004time\030\001 \001(\r\022\016\n\006opcode\030\002 \001(\r\022\016\n\006sector\030"
    "\003 \001(\004\022\017\n\007details\030\004 \001(\t\022\037\n\006result\030\005 \001(\0132\017"
    ".ScsiResultData\"B\n\027CommandErrorReportsDa"
    "ta\022\'\n\006report\030\001 \003(\0132\027.CommandErrorReportD"
    "ata\"\255\001\n\027VolumeInfoDetachingData\022\021\n\tvolum"
    "e_id\030\001 \002(\r\022\032\n\022former_device_name\030\002 \001(\t\022\033"
    "\n\023former_logical_size\030\003 \001(\004\022\026\n\016start_blo"
    "ck_id\030\004 \001(\004\022\024\n\014end_block_id\030\005 \001(\004\022\030\n\020cur"
    "rent_block_id\030\006 \001(\004\"\271\001\n\025VolumeFastCopyJo"
    "bData\022\025\n\rsrc_volume_id\030\001 \002(\r\022\030\n\020target_v"
    "olume_id\030\002 \002(\r\022\030\n\020src_start_offset\030\003 \001(\004"
    "\022\033\n\023target_start_offset\030\004 \001(\004\022\014\n\004size\030\005 "
    "\001(\004\022\026\n\016current_offset\030\006 \001(\004\022\022\n\njob_faile"
    "d\030\007 \001(\010\">\n\026VolumeInfoFastCopyData\022$\n\004job"
    "s\030\001 \003(\0132\026.VolumeFastCopyJobData\">\n\rGroup"
    "InfoData\022\022\n\ngroup_name\030\001 \001(\t\022\031\n\021initiato"
    "r_pattern\030\002 \003(\t\"2\n\016TargetAuthData\022\020\n\010use"
    "rname\030\001 \001(\t\022\016\n\006secret\030\002 \001(\t\"a\n\016TargetInf"
    "oData\022\023\n\013target_name\030\001 \001(\t\022\013\n\003tid\030\002 \001(\r\022"
    "\016\n\006params\030\003 \003(\t\022\035\n\004auth\030\004 \001(\0132\017.TargetAu"
    "thData\"_\n\014UserInfoData\022\021\n\tuser_name\030\001 \001("
    "\t\022\016\n\006secret\030\003 \001(\t\022\017\n\007targets\030\002 \003(\t\022\033\n\020en"
    "coding_version\030\004 \001(\r:\0010\"Q\n\rDirtyFileData"
    "\022\r\n\005clean\030\001 \001(\010\022\016\n\006config\030\002 \001(\t\022\017\n\007stopp"
    "ed\030\003 \001(\010\022\020\n\010revision\030\004 \001(\t*M\n\023VolumeInfo"
    "StateData\022\030\n\024VOLUME_STATE_RUNNING\020\000\022\034\n\030V"
    "OLUME_STATE_MAINTENANCE\020\001", 1545);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "dedupv1d.proto", &protobuf_RegisterTypes);
  OptionPair::default_instance_ = new OptionPair();
  VolumeInfoData::default_instance_ = new VolumeInfoData();
  ScsiResultData::default_instance_ = new ScsiResultData();
  CommandErrorReportData::default_instance_ = new CommandErrorReportData();
  CommandErrorReportsData::default_instance_ = new CommandErrorReportsData();
  VolumeInfoDetachingData::default_instance_ = new VolumeInfoDetachingData();
  VolumeFastCopyJobData::default_instance_ = new VolumeFastCopyJobData();
  VolumeInfoFastCopyData::default_instance_ = new VolumeInfoFastCopyData();
  GroupInfoData::default_instance_ = new GroupInfoData();
  TargetAuthData::default_instance_ = new TargetAuthData();
  TargetInfoData::default_instance_ = new TargetInfoData();
  UserInfoData::default_instance_ = new UserInfoData();
  DirtyFileData::default_instance_ = new DirtyFileData();
  OptionPair::default_instance_->InitAsDefaultInstance();
  VolumeInfoData::default_instance_->InitAsDefaultInstance();
  ScsiResultData::default_instance_->InitAsDefaultInstance();
  CommandErrorReportData::default_instance_->InitAsDefaultInstance();
  CommandErrorReportsData::default_instance_->InitAsDefaultInstance();
  VolumeInfoDetachingData::default_instance_->InitAsDefaultInstance();
  VolumeFastCopyJobData::default_instance_->InitAsDefaultInstance();
  VolumeInfoFastCopyData::default_instance_->InitAsDefaultInstance();
  GroupInfoData::default_instance_->InitAsDefaultInstance();
  TargetAuthData::default_instance_->InitAsDefaultInstance();
  TargetInfoData::default_instance_->InitAsDefaultInstance();
  UserInfoData::default_instance_->InitAsDefaultInstance();
  DirtyFileData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_dedupv1d_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_dedupv1d_2eproto {
  StaticDescriptorInitializer_dedupv1d_2eproto() {
    protobuf_AddDesc_dedupv1d_2eproto();
  }
} static_descriptor_initializer_dedupv1d_2eproto_;
const ::google::protobuf::EnumDescriptor* VolumeInfoStateData_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VolumeInfoStateData_descriptor_;
}
bool VolumeInfoStateData_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int OptionPair::kOptionNameFieldNumber;
const int OptionPair::kOptionFieldNumber;
#endif  // !_MSC_VER

OptionPair::OptionPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void OptionPair::InitAsDefaultInstance() {
}

OptionPair::OptionPair(const OptionPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void OptionPair::SharedCtor() {
  _cached_size_ = 0;
  option_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  option_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OptionPair::~OptionPair() {
  SharedDtor();
}

void OptionPair::SharedDtor() {
  if (option_name_ != &::google::protobuf::internal::kEmptyString) {
    delete option_name_;
  }
  if (option_ != &::google::protobuf::internal::kEmptyString) {
    delete option_;
  }
  if (this != default_instance_) {
  }
}

void OptionPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OptionPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OptionPair_descriptor_;
}

const OptionPair& OptionPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

OptionPair* OptionPair::default_instance_ = NULL;

OptionPair* OptionPair::New() const {
  return new OptionPair;
}

void OptionPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_option_name()) {
      if (option_name_ != &::google::protobuf::internal::kEmptyString) {
        option_name_->clear();
      }
    }
    if (has_option()) {
      if (option_ != &::google::protobuf::internal::kEmptyString) {
        option_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OptionPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string option_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_option_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->option_name().data(), this->option_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_option;
        break;
      }

      // required string option = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_option:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_option()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->option().data(), this->option().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OptionPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string option_name = 1;
  if (has_option_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->option_name().data(), this->option_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->option_name(), output);
  }

  // required string option = 2;
  if (has_option()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->option().data(), this->option().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->option(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OptionPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string option_name = 1;
  if (has_option_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->option_name().data(), this->option_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->option_name(), target);
  }

  // required string option = 2;
  if (has_option()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->option().data(), this->option().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->option(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OptionPair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string option_name = 1;
    if (has_option_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->option_name());
    }

    // required string option = 2;
    if (has_option()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->option());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OptionPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OptionPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OptionPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OptionPair::MergeFrom(const OptionPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_option_name()) {
      set_option_name(from.option_name());
    }
    if (from.has_option()) {
      set_option(from.option());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OptionPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OptionPair::CopyFrom(const OptionPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OptionPair::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void OptionPair::Swap(OptionPair* other) {
  if (other != this) {
    std::swap(option_name_, other->option_name_);
    std::swap(option_, other->option_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OptionPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OptionPair_descriptor_;
  metadata.reflection = OptionPair_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VolumeInfoData::kVolumeIdFieldNumber;
const int VolumeInfoData::kDeviceNameFieldNumber;
const int VolumeInfoData::kLogicalSizeFieldNumber;
const int VolumeInfoData::kCommandThreadCountFieldNumber;
const int VolumeInfoData::kGroupsFieldNumber;
const int VolumeInfoData::kTargetsFieldNumber;
const int VolumeInfoData::kStateFieldNumber;
const int VolumeInfoData::kSectorSizeFieldNumber;
const int VolumeInfoData::kChunkingOptionsFieldNumber;
const int VolumeInfoData::kFilterChainOptionsFieldNumber;
#endif  // !_MSC_VER

VolumeInfoData::VolumeInfoData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VolumeInfoData::InitAsDefaultInstance() {
}

VolumeInfoData::VolumeInfoData(const VolumeInfoData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VolumeInfoData::SharedCtor() {
  _cached_size_ = 0;
  volume_id_ = 0u;
  device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  logical_size_ = GOOGLE_ULONGLONG(0);
  command_thread_count_ = 0u;
  state_ = 0;
  sector_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VolumeInfoData::~VolumeInfoData() {
  SharedDtor();
}

void VolumeInfoData::SharedDtor() {
  if (device_name_ != &::google::protobuf::internal::kEmptyString) {
    delete device_name_;
  }
  if (this != default_instance_) {
  }
}

void VolumeInfoData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VolumeInfoData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VolumeInfoData_descriptor_;
}

const VolumeInfoData& VolumeInfoData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

VolumeInfoData* VolumeInfoData::default_instance_ = NULL;

VolumeInfoData* VolumeInfoData::New() const {
  return new VolumeInfoData;
}

void VolumeInfoData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    volume_id_ = 0u;
    if (has_device_name()) {
      if (device_name_ != &::google::protobuf::internal::kEmptyString) {
        device_name_->clear();
      }
    }
    logical_size_ = GOOGLE_ULONGLONG(0);
    command_thread_count_ = 0u;
    state_ = 0;
    sector_size_ = 0u;
  }
  groups_.Clear();
  targets_.Clear();
  chunking_options_.Clear();
  filter_chain_options_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VolumeInfoData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 volume_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &volume_id_)));
          set_has_volume_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_device_name;
        break;
      }

      // optional string device_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_device_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->device_name().data(), this->device_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_logical_size;
        break;
      }

      // optional uint64 logical_size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_logical_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &logical_size_)));
          set_has_logical_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_command_thread_count;
        break;
      }

      // optional uint32 command_thread_count = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_command_thread_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &command_thread_count_)));
          set_has_command_thread_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_groups;
        break;
      }

      // repeated string groups = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_groups:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_groups()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->groups(this->groups_size() - 1).data(),
            this->groups(this->groups_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_groups;
        if (input->ExpectTag(48)) goto parse_state;
        break;
      }

      // optional .VolumeInfoStateData state = 6 [default = VOLUME_STATE_RUNNING];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::VolumeInfoStateData_IsValid(value)) {
            set_state(static_cast< ::VolumeInfoStateData >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_sector_size;
        break;
      }

      // optional uint32 sector_size = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sector_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sector_size_)));
          set_has_sector_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_targets;
        break;
      }

      // repeated string targets = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_targets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_targets()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->targets(this->targets_size() - 1).data(),
            this->targets(this->targets_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_targets;
        if (input->ExpectTag(74)) goto parse_chunking_options;
        break;
      }

      // repeated .OptionPair chunking_options = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chunking_options:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_chunking_options()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_chunking_options;
        if (input->ExpectTag(82)) goto parse_filter_chain_options;
        break;
      }

      // repeated .OptionPair filter_chain_options = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_chain_options:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_filter_chain_options()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_filter_chain_options;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VolumeInfoData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 volume_id = 1;
  if (has_volume_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->volume_id(), output);
  }

  // optional string device_name = 2;
  if (has_device_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->device_name().data(), this->device_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->device_name(), output);
  }

  // optional uint64 logical_size = 3;
  if (has_logical_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->logical_size(), output);
  }

  // optional uint32 command_thread_count = 4;
  if (has_command_thread_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->command_thread_count(), output);
  }

  // repeated string groups = 5;
  for (int i = 0; i < this->groups_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->groups(i).data(), this->groups(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->groups(i), output);
  }

  // optional .VolumeInfoStateData state = 6 [default = VOLUME_STATE_RUNNING];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->state(), output);
  }

  // optional uint32 sector_size = 7;
  if (has_sector_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->sector_size(), output);
  }

  // repeated string targets = 8;
  for (int i = 0; i < this->targets_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->targets(i).data(), this->targets(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->targets(i), output);
  }

  // repeated .OptionPair chunking_options = 9;
  for (int i = 0; i < this->chunking_options_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->chunking_options(i), output);
  }

  // repeated .OptionPair filter_chain_options = 10;
  for (int i = 0; i < this->filter_chain_options_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->filter_chain_options(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VolumeInfoData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 volume_id = 1;
  if (has_volume_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->volume_id(), target);
  }

  // optional string device_name = 2;
  if (has_device_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->device_name().data(), this->device_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->device_name(), target);
  }

  // optional uint64 logical_size = 3;
  if (has_logical_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->logical_size(), target);
  }

  // optional uint32 command_thread_count = 4;
  if (has_command_thread_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->command_thread_count(), target);
  }

  // repeated string groups = 5;
  for (int i = 0; i < this->groups_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->groups(i).data(), this->groups(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(5, this->groups(i), target);
  }

  // optional .VolumeInfoStateData state = 6 [default = VOLUME_STATE_RUNNING];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->state(), target);
  }

  // optional uint32 sector_size = 7;
  if (has_sector_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->sector_size(), target);
  }

  // repeated string targets = 8;
  for (int i = 0; i < this->targets_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->targets(i).data(), this->targets(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(8, this->targets(i), target);
  }

  // repeated .OptionPair chunking_options = 9;
  for (int i = 0; i < this->chunking_options_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->chunking_options(i), target);
  }

  // repeated .OptionPair filter_chain_options = 10;
  for (int i = 0; i < this->filter_chain_options_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->filter_chain_options(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VolumeInfoData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 volume_id = 1;
    if (has_volume_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->volume_id());
    }

    // optional string device_name = 2;
    if (has_device_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_name());
    }

    // optional uint64 logical_size = 3;
    if (has_logical_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->logical_size());
    }

    // optional uint32 command_thread_count = 4;
    if (has_command_thread_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->command_thread_count());
    }

    // optional .VolumeInfoStateData state = 6 [default = VOLUME_STATE_RUNNING];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional uint32 sector_size = 7;
    if (has_sector_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sector_size());
    }

  }
  // repeated string groups = 5;
  total_size += 1 * this->groups_size();
  for (int i = 0; i < this->groups_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->groups(i));
  }

  // repeated string targets = 8;
  total_size += 1 * this->targets_size();
  for (int i = 0; i < this->targets_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->targets(i));
  }

  // repeated .OptionPair chunking_options = 9;
  total_size += 1 * this->chunking_options_size();
  for (int i = 0; i < this->chunking_options_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->chunking_options(i));
  }

  // repeated .OptionPair filter_chain_options = 10;
  total_size += 1 * this->filter_chain_options_size();
  for (int i = 0; i < this->filter_chain_options_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->filter_chain_options(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VolumeInfoData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VolumeInfoData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VolumeInfoData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VolumeInfoData::MergeFrom(const VolumeInfoData& from) {
  GOOGLE_CHECK_NE(&from, this);
  groups_.MergeFrom(from.groups_);
  targets_.MergeFrom(from.targets_);
  chunking_options_.MergeFrom(from.chunking_options_);
  filter_chain_options_.MergeFrom(from.filter_chain_options_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_volume_id()) {
      set_volume_id(from.volume_id());
    }
    if (from.has_device_name()) {
      set_device_name(from.device_name());
    }
    if (from.has_logical_size()) {
      set_logical_size(from.logical_size());
    }
    if (from.has_command_thread_count()) {
      set_command_thread_count(from.command_thread_count());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_sector_size()) {
      set_sector_size(from.sector_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VolumeInfoData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VolumeInfoData::CopyFrom(const VolumeInfoData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeInfoData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < chunking_options_size(); i++) {
    if (!this->chunking_options(i).IsInitialized()) return false;
  }
  for (int i = 0; i < filter_chain_options_size(); i++) {
    if (!this->filter_chain_options(i).IsInitialized()) return false;
  }
  return true;
}

void VolumeInfoData::Swap(VolumeInfoData* other) {
  if (other != this) {
    std::swap(volume_id_, other->volume_id_);
    std::swap(device_name_, other->device_name_);
    std::swap(logical_size_, other->logical_size_);
    std::swap(command_thread_count_, other->command_thread_count_);
    groups_.Swap(&other->groups_);
    targets_.Swap(&other->targets_);
    std::swap(state_, other->state_);
    std::swap(sector_size_, other->sector_size_);
    chunking_options_.Swap(&other->chunking_options_);
    filter_chain_options_.Swap(&other->filter_chain_options_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VolumeInfoData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VolumeInfoData_descriptor_;
  metadata.reflection = VolumeInfoData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ScsiResultData::kResultFieldNumber;
const int ScsiResultData::kSenseKeyFieldNumber;
const int ScsiResultData::kAscFieldNumber;
const int ScsiResultData::kAscqFieldNumber;
#endif  // !_MSC_VER

ScsiResultData::ScsiResultData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ScsiResultData::InitAsDefaultInstance() {
}

ScsiResultData::ScsiResultData(const ScsiResultData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ScsiResultData::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0u;
  sense_key_ = 0u;
  asc_ = 0u;
  ascq_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScsiResultData::~ScsiResultData() {
  SharedDtor();
}

void ScsiResultData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ScsiResultData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScsiResultData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScsiResultData_descriptor_;
}

const ScsiResultData& ScsiResultData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

ScsiResultData* ScsiResultData::default_instance_ = NULL;

ScsiResultData* ScsiResultData::New() const {
  return new ScsiResultData;
}

void ScsiResultData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0u;
    sense_key_ = 0u;
    asc_ = 0u;
    ascq_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ScsiResultData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sense_key;
        break;
      }

      // optional uint32 sense_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sense_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sense_key_)));
          set_has_sense_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_asc;
        break;
      }

      // optional uint32 asc = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_asc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &asc_)));
          set_has_asc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ascq;
        break;
      }

      // optional uint32 ascq = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ascq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ascq_)));
          set_has_ascq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ScsiResultData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result(), output);
  }

  // optional uint32 sense_key = 2;
  if (has_sense_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sense_key(), output);
  }

  // optional uint32 asc = 3;
  if (has_asc()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->asc(), output);
  }

  // optional uint32 ascq = 4;
  if (has_ascq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->ascq(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ScsiResultData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->result(), target);
  }

  // optional uint32 sense_key = 2;
  if (has_sense_key()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->sense_key(), target);
  }

  // optional uint32 asc = 3;
  if (has_asc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->asc(), target);
  }

  // optional uint32 ascq = 4;
  if (has_ascq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->ascq(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ScsiResultData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional uint32 sense_key = 2;
    if (has_sense_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sense_key());
    }

    // optional uint32 asc = 3;
    if (has_asc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->asc());
    }

    // optional uint32 ascq = 4;
    if (has_ascq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ascq());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScsiResultData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ScsiResultData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ScsiResultData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScsiResultData::MergeFrom(const ScsiResultData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_sense_key()) {
      set_sense_key(from.sense_key());
    }
    if (from.has_asc()) {
      set_asc(from.asc());
    }
    if (from.has_ascq()) {
      set_ascq(from.ascq());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ScsiResultData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScsiResultData::CopyFrom(const ScsiResultData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScsiResultData::IsInitialized() const {

  return true;
}

void ScsiResultData::Swap(ScsiResultData* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(sense_key_, other->sense_key_);
    std::swap(asc_, other->asc_);
    std::swap(ascq_, other->ascq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ScsiResultData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScsiResultData_descriptor_;
  metadata.reflection = ScsiResultData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CommandErrorReportData::kTimeFieldNumber;
const int CommandErrorReportData::kOpcodeFieldNumber;
const int CommandErrorReportData::kSectorFieldNumber;
const int CommandErrorReportData::kDetailsFieldNumber;
const int CommandErrorReportData::kResultFieldNumber;
#endif  // !_MSC_VER

CommandErrorReportData::CommandErrorReportData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CommandErrorReportData::InitAsDefaultInstance() {
  result_ = const_cast< ::ScsiResultData*>(&::ScsiResultData::default_instance());
}

CommandErrorReportData::CommandErrorReportData(const CommandErrorReportData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CommandErrorReportData::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0u;
  opcode_ = 0u;
  sector_ = GOOGLE_ULONGLONG(0);
  details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  result_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommandErrorReportData::~CommandErrorReportData() {
  SharedDtor();
}

void CommandErrorReportData::SharedDtor() {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    delete details_;
  }
  if (this != default_instance_) {
    delete result_;
  }
}

void CommandErrorReportData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CommandErrorReportData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CommandErrorReportData_descriptor_;
}

const CommandErrorReportData& CommandErrorReportData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

CommandErrorReportData* CommandErrorReportData::default_instance_ = NULL;

CommandErrorReportData* CommandErrorReportData::New() const {
  return new CommandErrorReportData;
}

void CommandErrorReportData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0u;
    opcode_ = 0u;
    sector_ = GOOGLE_ULONGLONG(0);
    if (has_details()) {
      if (details_ != &::google::protobuf::internal::kEmptyString) {
        details_->clear();
      }
    }
    if (has_result()) {
      if (result_ != NULL) result_->::ScsiResultData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CommandErrorReportData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_opcode;
        break;
      }

      // optional uint32 opcode = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_opcode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &opcode_)));
          set_has_opcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sector;
        break;
      }

      // optional uint64 sector = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sector:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sector_)));
          set_has_sector();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_details;
        break;
      }

      // optional string details = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_details:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_details()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->details().data(), this->details().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_result;
        break;
      }

      // optional .ScsiResultData result = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_result()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CommandErrorReportData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time(), output);
  }

  // optional uint32 opcode = 2;
  if (has_opcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->opcode(), output);
  }

  // optional uint64 sector = 3;
  if (has_sector()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->sector(), output);
  }

  // optional string details = 4;
  if (has_details()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->details().data(), this->details().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->details(), output);
  }

  // optional .ScsiResultData result = 5;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->result(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CommandErrorReportData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time(), target);
  }

  // optional uint32 opcode = 2;
  if (has_opcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->opcode(), target);
  }

  // optional uint64 sector = 3;
  if (has_sector()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->sector(), target);
  }

  // optional string details = 4;
  if (has_details()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->details().data(), this->details().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->details(), target);
  }

  // optional .ScsiResultData result = 5;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->result(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CommandErrorReportData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 time = 1;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // optional uint32 opcode = 2;
    if (has_opcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->opcode());
    }

    // optional uint64 sector = 3;
    if (has_sector()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sector());
    }

    // optional string details = 4;
    if (has_details()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->details());
    }

    // optional .ScsiResultData result = 5;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->result());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommandErrorReportData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CommandErrorReportData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CommandErrorReportData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CommandErrorReportData::MergeFrom(const CommandErrorReportData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_opcode()) {
      set_opcode(from.opcode());
    }
    if (from.has_sector()) {
      set_sector(from.sector());
    }
    if (from.has_details()) {
      set_details(from.details());
    }
    if (from.has_result()) {
      mutable_result()->::ScsiResultData::MergeFrom(from.result());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CommandErrorReportData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CommandErrorReportData::CopyFrom(const CommandErrorReportData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandErrorReportData::IsInitialized() const {

  return true;
}

void CommandErrorReportData::Swap(CommandErrorReportData* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(opcode_, other->opcode_);
    std::swap(sector_, other->sector_);
    std::swap(details_, other->details_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CommandErrorReportData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CommandErrorReportData_descriptor_;
  metadata.reflection = CommandErrorReportData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CommandErrorReportsData::kReportFieldNumber;
#endif  // !_MSC_VER

CommandErrorReportsData::CommandErrorReportsData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CommandErrorReportsData::InitAsDefaultInstance() {
}

CommandErrorReportsData::CommandErrorReportsData(const CommandErrorReportsData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CommandErrorReportsData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommandErrorReportsData::~CommandErrorReportsData() {
  SharedDtor();
}

void CommandErrorReportsData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CommandErrorReportsData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CommandErrorReportsData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CommandErrorReportsData_descriptor_;
}

const CommandErrorReportsData& CommandErrorReportsData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

CommandErrorReportsData* CommandErrorReportsData::default_instance_ = NULL;

CommandErrorReportsData* CommandErrorReportsData::New() const {
  return new CommandErrorReportsData;
}

void CommandErrorReportsData::Clear() {
  report_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CommandErrorReportsData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CommandErrorReportData report = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_report:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_report()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_report;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CommandErrorReportsData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .CommandErrorReportData report = 1;
  for (int i = 0; i < this->report_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->report(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CommandErrorReportsData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .CommandErrorReportData report = 1;
  for (int i = 0; i < this->report_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->report(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CommandErrorReportsData::ByteSize() const {
  int total_size = 0;

  // repeated .CommandErrorReportData report = 1;
  total_size += 1 * this->report_size();
  for (int i = 0; i < this->report_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->report(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommandErrorReportsData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CommandErrorReportsData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CommandErrorReportsData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CommandErrorReportsData::MergeFrom(const CommandErrorReportsData& from) {
  GOOGLE_CHECK_NE(&from, this);
  report_.MergeFrom(from.report_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CommandErrorReportsData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CommandErrorReportsData::CopyFrom(const CommandErrorReportsData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandErrorReportsData::IsInitialized() const {

  return true;
}

void CommandErrorReportsData::Swap(CommandErrorReportsData* other) {
  if (other != this) {
    report_.Swap(&other->report_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CommandErrorReportsData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CommandErrorReportsData_descriptor_;
  metadata.reflection = CommandErrorReportsData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VolumeInfoDetachingData::kVolumeIdFieldNumber;
const int VolumeInfoDetachingData::kFormerDeviceNameFieldNumber;
const int VolumeInfoDetachingData::kFormerLogicalSizeFieldNumber;
const int VolumeInfoDetachingData::kStartBlockIdFieldNumber;
const int VolumeInfoDetachingData::kEndBlockIdFieldNumber;
const int VolumeInfoDetachingData::kCurrentBlockIdFieldNumber;
#endif  // !_MSC_VER

VolumeInfoDetachingData::VolumeInfoDetachingData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VolumeInfoDetachingData::InitAsDefaultInstance() {
}

VolumeInfoDetachingData::VolumeInfoDetachingData(const VolumeInfoDetachingData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VolumeInfoDetachingData::SharedCtor() {
  _cached_size_ = 0;
  volume_id_ = 0u;
  former_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  former_logical_size_ = GOOGLE_ULONGLONG(0);
  start_block_id_ = GOOGLE_ULONGLONG(0);
  end_block_id_ = GOOGLE_ULONGLONG(0);
  current_block_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VolumeInfoDetachingData::~VolumeInfoDetachingData() {
  SharedDtor();
}

void VolumeInfoDetachingData::SharedDtor() {
  if (former_device_name_ != &::google::protobuf::internal::kEmptyString) {
    delete former_device_name_;
  }
  if (this != default_instance_) {
  }
}

void VolumeInfoDetachingData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VolumeInfoDetachingData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VolumeInfoDetachingData_descriptor_;
}

const VolumeInfoDetachingData& VolumeInfoDetachingData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

VolumeInfoDetachingData* VolumeInfoDetachingData::default_instance_ = NULL;

VolumeInfoDetachingData* VolumeInfoDetachingData::New() const {
  return new VolumeInfoDetachingData;
}

void VolumeInfoDetachingData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    volume_id_ = 0u;
    if (has_former_device_name()) {
      if (former_device_name_ != &::google::protobuf::internal::kEmptyString) {
        former_device_name_->clear();
      }
    }
    former_logical_size_ = GOOGLE_ULONGLONG(0);
    start_block_id_ = GOOGLE_ULONGLONG(0);
    end_block_id_ = GOOGLE_ULONGLONG(0);
    current_block_id_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VolumeInfoDetachingData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 volume_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &volume_id_)));
          set_has_volume_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_former_device_name;
        break;
      }

      // optional string former_device_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_former_device_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_former_device_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->former_device_name().data(), this->former_device_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_former_logical_size;
        break;
      }

      // optional uint64 former_logical_size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_former_logical_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &former_logical_size_)));
          set_has_former_logical_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_start_block_id;
        break;
      }

      // optional uint64 start_block_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_block_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_block_id_)));
          set_has_start_block_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_end_block_id;
        break;
      }

      // optional uint64 end_block_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_block_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &end_block_id_)));
          set_has_end_block_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_current_block_id;
        break;
      }

      // optional uint64 current_block_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_current_block_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &current_block_id_)));
          set_has_current_block_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VolumeInfoDetachingData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 volume_id = 1;
  if (has_volume_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->volume_id(), output);
  }

  // optional string former_device_name = 2;
  if (has_former_device_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->former_device_name().data(), this->former_device_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->former_device_name(), output);
  }

  // optional uint64 former_logical_size = 3;
  if (has_former_logical_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->former_logical_size(), output);
  }

  // optional uint64 start_block_id = 4;
  if (has_start_block_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->start_block_id(), output);
  }

  // optional uint64 end_block_id = 5;
  if (has_end_block_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->end_block_id(), output);
  }

  // optional uint64 current_block_id = 6;
  if (has_current_block_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->current_block_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VolumeInfoDetachingData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 volume_id = 1;
  if (has_volume_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->volume_id(), target);
  }

  // optional string former_device_name = 2;
  if (has_former_device_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->former_device_name().data(), this->former_device_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->former_device_name(), target);
  }

  // optional uint64 former_logical_size = 3;
  if (has_former_logical_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->former_logical_size(), target);
  }

  // optional uint64 start_block_id = 4;
  if (has_start_block_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->start_block_id(), target);
  }

  // optional uint64 end_block_id = 5;
  if (has_end_block_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->end_block_id(), target);
  }

  // optional uint64 current_block_id = 6;
  if (has_current_block_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->current_block_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VolumeInfoDetachingData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 volume_id = 1;
    if (has_volume_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->volume_id());
    }

    // optional string former_device_name = 2;
    if (has_former_device_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->former_device_name());
    }

    // optional uint64 former_logical_size = 3;
    if (has_former_logical_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->former_logical_size());
    }

    // optional uint64 start_block_id = 4;
    if (has_start_block_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->start_block_id());
    }

    // optional uint64 end_block_id = 5;
    if (has_end_block_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->end_block_id());
    }

    // optional uint64 current_block_id = 6;
    if (has_current_block_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->current_block_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VolumeInfoDetachingData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VolumeInfoDetachingData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VolumeInfoDetachingData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VolumeInfoDetachingData::MergeFrom(const VolumeInfoDetachingData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_volume_id()) {
      set_volume_id(from.volume_id());
    }
    if (from.has_former_device_name()) {
      set_former_device_name(from.former_device_name());
    }
    if (from.has_former_logical_size()) {
      set_former_logical_size(from.former_logical_size());
    }
    if (from.has_start_block_id()) {
      set_start_block_id(from.start_block_id());
    }
    if (from.has_end_block_id()) {
      set_end_block_id(from.end_block_id());
    }
    if (from.has_current_block_id()) {
      set_current_block_id(from.current_block_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VolumeInfoDetachingData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VolumeInfoDetachingData::CopyFrom(const VolumeInfoDetachingData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeInfoDetachingData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void VolumeInfoDetachingData::Swap(VolumeInfoDetachingData* other) {
  if (other != this) {
    std::swap(volume_id_, other->volume_id_);
    std::swap(former_device_name_, other->former_device_name_);
    std::swap(former_logical_size_, other->former_logical_size_);
    std::swap(start_block_id_, other->start_block_id_);
    std::swap(end_block_id_, other->end_block_id_);
    std::swap(current_block_id_, other->current_block_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VolumeInfoDetachingData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VolumeInfoDetachingData_descriptor_;
  metadata.reflection = VolumeInfoDetachingData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VolumeFastCopyJobData::kSrcVolumeIdFieldNumber;
const int VolumeFastCopyJobData::kTargetVolumeIdFieldNumber;
const int VolumeFastCopyJobData::kSrcStartOffsetFieldNumber;
const int VolumeFastCopyJobData::kTargetStartOffsetFieldNumber;
const int VolumeFastCopyJobData::kSizeFieldNumber;
const int VolumeFastCopyJobData::kCurrentOffsetFieldNumber;
const int VolumeFastCopyJobData::kJobFailedFieldNumber;
#endif  // !_MSC_VER

VolumeFastCopyJobData::VolumeFastCopyJobData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VolumeFastCopyJobData::InitAsDefaultInstance() {
}

VolumeFastCopyJobData::VolumeFastCopyJobData(const VolumeFastCopyJobData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VolumeFastCopyJobData::SharedCtor() {
  _cached_size_ = 0;
  src_volume_id_ = 0u;
  target_volume_id_ = 0u;
  src_start_offset_ = GOOGLE_ULONGLONG(0);
  target_start_offset_ = GOOGLE_ULONGLONG(0);
  size_ = GOOGLE_ULONGLONG(0);
  current_offset_ = GOOGLE_ULONGLONG(0);
  job_failed_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VolumeFastCopyJobData::~VolumeFastCopyJobData() {
  SharedDtor();
}

void VolumeFastCopyJobData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VolumeFastCopyJobData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VolumeFastCopyJobData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VolumeFastCopyJobData_descriptor_;
}

const VolumeFastCopyJobData& VolumeFastCopyJobData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

VolumeFastCopyJobData* VolumeFastCopyJobData::default_instance_ = NULL;

VolumeFastCopyJobData* VolumeFastCopyJobData::New() const {
  return new VolumeFastCopyJobData;
}

void VolumeFastCopyJobData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    src_volume_id_ = 0u;
    target_volume_id_ = 0u;
    src_start_offset_ = GOOGLE_ULONGLONG(0);
    target_start_offset_ = GOOGLE_ULONGLONG(0);
    size_ = GOOGLE_ULONGLONG(0);
    current_offset_ = GOOGLE_ULONGLONG(0);
    job_failed_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VolumeFastCopyJobData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 src_volume_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &src_volume_id_)));
          set_has_src_volume_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_target_volume_id;
        break;
      }

      // required uint32 target_volume_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_volume_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_volume_id_)));
          set_has_target_volume_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_src_start_offset;
        break;
      }

      // optional uint64 src_start_offset = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_src_start_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &src_start_offset_)));
          set_has_src_start_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_target_start_offset;
        break;
      }

      // optional uint64 target_start_offset = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_start_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &target_start_offset_)));
          set_has_target_start_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_size;
        break;
      }

      // optional uint64 size = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_current_offset;
        break;
      }

      // optional uint64 current_offset = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_current_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &current_offset_)));
          set_has_current_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_job_failed;
        break;
      }

      // optional bool job_failed = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job_failed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &job_failed_)));
          set_has_job_failed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VolumeFastCopyJobData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 src_volume_id = 1;
  if (has_src_volume_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->src_volume_id(), output);
  }

  // required uint32 target_volume_id = 2;
  if (has_target_volume_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_volume_id(), output);
  }

  // optional uint64 src_start_offset = 3;
  if (has_src_start_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->src_start_offset(), output);
  }

  // optional uint64 target_start_offset = 4;
  if (has_target_start_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->target_start_offset(), output);
  }

  // optional uint64 size = 5;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->size(), output);
  }

  // optional uint64 current_offset = 6;
  if (has_current_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->current_offset(), output);
  }

  // optional bool job_failed = 7;
  if (has_job_failed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->job_failed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VolumeFastCopyJobData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 src_volume_id = 1;
  if (has_src_volume_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->src_volume_id(), target);
  }

  // required uint32 target_volume_id = 2;
  if (has_target_volume_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->target_volume_id(), target);
  }

  // optional uint64 src_start_offset = 3;
  if (has_src_start_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->src_start_offset(), target);
  }

  // optional uint64 target_start_offset = 4;
  if (has_target_start_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->target_start_offset(), target);
  }

  // optional uint64 size = 5;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->size(), target);
  }

  // optional uint64 current_offset = 6;
  if (has_current_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->current_offset(), target);
  }

  // optional bool job_failed = 7;
  if (has_job_failed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->job_failed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VolumeFastCopyJobData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 src_volume_id = 1;
    if (has_src_volume_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->src_volume_id());
    }

    // required uint32 target_volume_id = 2;
    if (has_target_volume_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_volume_id());
    }

    // optional uint64 src_start_offset = 3;
    if (has_src_start_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->src_start_offset());
    }

    // optional uint64 target_start_offset = 4;
    if (has_target_start_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->target_start_offset());
    }

    // optional uint64 size = 5;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }

    // optional uint64 current_offset = 6;
    if (has_current_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->current_offset());
    }

    // optional bool job_failed = 7;
    if (has_job_failed()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VolumeFastCopyJobData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VolumeFastCopyJobData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VolumeFastCopyJobData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VolumeFastCopyJobData::MergeFrom(const VolumeFastCopyJobData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_src_volume_id()) {
      set_src_volume_id(from.src_volume_id());
    }
    if (from.has_target_volume_id()) {
      set_target_volume_id(from.target_volume_id());
    }
    if (from.has_src_start_offset()) {
      set_src_start_offset(from.src_start_offset());
    }
    if (from.has_target_start_offset()) {
      set_target_start_offset(from.target_start_offset());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_current_offset()) {
      set_current_offset(from.current_offset());
    }
    if (from.has_job_failed()) {
      set_job_failed(from.job_failed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VolumeFastCopyJobData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VolumeFastCopyJobData::CopyFrom(const VolumeFastCopyJobData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeFastCopyJobData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void VolumeFastCopyJobData::Swap(VolumeFastCopyJobData* other) {
  if (other != this) {
    std::swap(src_volume_id_, other->src_volume_id_);
    std::swap(target_volume_id_, other->target_volume_id_);
    std::swap(src_start_offset_, other->src_start_offset_);
    std::swap(target_start_offset_, other->target_start_offset_);
    std::swap(size_, other->size_);
    std::swap(current_offset_, other->current_offset_);
    std::swap(job_failed_, other->job_failed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VolumeFastCopyJobData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VolumeFastCopyJobData_descriptor_;
  metadata.reflection = VolumeFastCopyJobData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VolumeInfoFastCopyData::kJobsFieldNumber;
#endif  // !_MSC_VER

VolumeInfoFastCopyData::VolumeInfoFastCopyData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VolumeInfoFastCopyData::InitAsDefaultInstance() {
}

VolumeInfoFastCopyData::VolumeInfoFastCopyData(const VolumeInfoFastCopyData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VolumeInfoFastCopyData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VolumeInfoFastCopyData::~VolumeInfoFastCopyData() {
  SharedDtor();
}

void VolumeInfoFastCopyData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VolumeInfoFastCopyData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VolumeInfoFastCopyData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VolumeInfoFastCopyData_descriptor_;
}

const VolumeInfoFastCopyData& VolumeInfoFastCopyData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

VolumeInfoFastCopyData* VolumeInfoFastCopyData::default_instance_ = NULL;

VolumeInfoFastCopyData* VolumeInfoFastCopyData::New() const {
  return new VolumeInfoFastCopyData;
}

void VolumeInfoFastCopyData::Clear() {
  jobs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VolumeInfoFastCopyData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .VolumeFastCopyJobData jobs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_jobs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_jobs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_jobs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VolumeInfoFastCopyData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .VolumeFastCopyJobData jobs = 1;
  for (int i = 0; i < this->jobs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->jobs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VolumeInfoFastCopyData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .VolumeFastCopyJobData jobs = 1;
  for (int i = 0; i < this->jobs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->jobs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VolumeInfoFastCopyData::ByteSize() const {
  int total_size = 0;

  // repeated .VolumeFastCopyJobData jobs = 1;
  total_size += 1 * this->jobs_size();
  for (int i = 0; i < this->jobs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->jobs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VolumeInfoFastCopyData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VolumeInfoFastCopyData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VolumeInfoFastCopyData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VolumeInfoFastCopyData::MergeFrom(const VolumeInfoFastCopyData& from) {
  GOOGLE_CHECK_NE(&from, this);
  jobs_.MergeFrom(from.jobs_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VolumeInfoFastCopyData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VolumeInfoFastCopyData::CopyFrom(const VolumeInfoFastCopyData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeInfoFastCopyData::IsInitialized() const {

  for (int i = 0; i < jobs_size(); i++) {
    if (!this->jobs(i).IsInitialized()) return false;
  }
  return true;
}

void VolumeInfoFastCopyData::Swap(VolumeInfoFastCopyData* other) {
  if (other != this) {
    jobs_.Swap(&other->jobs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VolumeInfoFastCopyData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VolumeInfoFastCopyData_descriptor_;
  metadata.reflection = VolumeInfoFastCopyData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GroupInfoData::kGroupNameFieldNumber;
const int GroupInfoData::kInitiatorPatternFieldNumber;
#endif  // !_MSC_VER

GroupInfoData::GroupInfoData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GroupInfoData::InitAsDefaultInstance() {
}

GroupInfoData::GroupInfoData(const GroupInfoData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GroupInfoData::SharedCtor() {
  _cached_size_ = 0;
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupInfoData::~GroupInfoData() {
  SharedDtor();
}

void GroupInfoData::SharedDtor() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (this != default_instance_) {
  }
}

void GroupInfoData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GroupInfoData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GroupInfoData_descriptor_;
}

const GroupInfoData& GroupInfoData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

GroupInfoData* GroupInfoData::default_instance_ = NULL;

GroupInfoData* GroupInfoData::New() const {
  return new GroupInfoData;
}

void GroupInfoData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::kEmptyString) {
        group_name_->clear();
      }
    }
  }
  initiator_pattern_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GroupInfoData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string group_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->group_name().data(), this->group_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_initiator_pattern;
        break;
      }

      // repeated string initiator_pattern = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_initiator_pattern:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_initiator_pattern()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->initiator_pattern(this->initiator_pattern_size() - 1).data(),
            this->initiator_pattern(this->initiator_pattern_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_initiator_pattern;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupInfoData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string group_name = 1;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->group_name().data(), this->group_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->group_name(), output);
  }

  // repeated string initiator_pattern = 2;
  for (int i = 0; i < this->initiator_pattern_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->initiator_pattern(i).data(), this->initiator_pattern(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->initiator_pattern(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GroupInfoData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string group_name = 1;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->group_name().data(), this->group_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->group_name(), target);
  }

  // repeated string initiator_pattern = 2;
  for (int i = 0; i < this->initiator_pattern_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->initiator_pattern(i).data(), this->initiator_pattern(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->initiator_pattern(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GroupInfoData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string group_name = 1;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

  }
  // repeated string initiator_pattern = 2;
  total_size += 1 * this->initiator_pattern_size();
  for (int i = 0; i < this->initiator_pattern_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->initiator_pattern(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupInfoData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GroupInfoData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GroupInfoData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GroupInfoData::MergeFrom(const GroupInfoData& from) {
  GOOGLE_CHECK_NE(&from, this);
  initiator_pattern_.MergeFrom(from.initiator_pattern_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GroupInfoData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GroupInfoData::CopyFrom(const GroupInfoData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInfoData::IsInitialized() const {

  return true;
}

void GroupInfoData::Swap(GroupInfoData* other) {
  if (other != this) {
    std::swap(group_name_, other->group_name_);
    initiator_pattern_.Swap(&other->initiator_pattern_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GroupInfoData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GroupInfoData_descriptor_;
  metadata.reflection = GroupInfoData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TargetAuthData::kUsernameFieldNumber;
const int TargetAuthData::kSecretFieldNumber;
#endif  // !_MSC_VER

TargetAuthData::TargetAuthData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TargetAuthData::InitAsDefaultInstance() {
}

TargetAuthData::TargetAuthData(const TargetAuthData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TargetAuthData::SharedCtor() {
  _cached_size_ = 0;
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TargetAuthData::~TargetAuthData() {
  SharedDtor();
}

void TargetAuthData::SharedDtor() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    delete secret_;
  }
  if (this != default_instance_) {
  }
}

void TargetAuthData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TargetAuthData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TargetAuthData_descriptor_;
}

const TargetAuthData& TargetAuthData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

TargetAuthData* TargetAuthData::default_instance_ = NULL;

TargetAuthData* TargetAuthData::New() const {
  return new TargetAuthData;
}

void TargetAuthData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
    if (has_secret()) {
      if (secret_ != &::google::protobuf::internal::kEmptyString) {
        secret_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TargetAuthData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string username = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_secret;
        break;
      }

      // optional string secret = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_secret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_secret()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->secret().data(), this->secret().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TargetAuthData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string username = 1;
  if (has_username()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->username(), output);
  }

  // optional string secret = 2;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->secret().data(), this->secret().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->secret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TargetAuthData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string username = 1;
  if (has_username()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->username(), target);
  }

  // optional string secret = 2;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->secret().data(), this->secret().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->secret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TargetAuthData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string username = 1;
    if (has_username()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }

    // optional string secret = 2;
    if (has_secret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->secret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TargetAuthData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TargetAuthData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TargetAuthData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TargetAuthData::MergeFrom(const TargetAuthData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_username()) {
      set_username(from.username());
    }
    if (from.has_secret()) {
      set_secret(from.secret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TargetAuthData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TargetAuthData::CopyFrom(const TargetAuthData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TargetAuthData::IsInitialized() const {

  return true;
}

void TargetAuthData::Swap(TargetAuthData* other) {
  if (other != this) {
    std::swap(username_, other->username_);
    std::swap(secret_, other->secret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TargetAuthData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TargetAuthData_descriptor_;
  metadata.reflection = TargetAuthData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TargetInfoData::kTargetNameFieldNumber;
const int TargetInfoData::kTidFieldNumber;
const int TargetInfoData::kParamsFieldNumber;
const int TargetInfoData::kAuthFieldNumber;
#endif  // !_MSC_VER

TargetInfoData::TargetInfoData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TargetInfoData::InitAsDefaultInstance() {
  auth_ = const_cast< ::TargetAuthData*>(&::TargetAuthData::default_instance());
}

TargetInfoData::TargetInfoData(const TargetInfoData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TargetInfoData::SharedCtor() {
  _cached_size_ = 0;
  target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  tid_ = 0u;
  auth_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TargetInfoData::~TargetInfoData() {
  SharedDtor();
}

void TargetInfoData::SharedDtor() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (this != default_instance_) {
    delete auth_;
  }
}

void TargetInfoData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TargetInfoData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TargetInfoData_descriptor_;
}

const TargetInfoData& TargetInfoData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

TargetInfoData* TargetInfoData::default_instance_ = NULL;

TargetInfoData* TargetInfoData::New() const {
  return new TargetInfoData;
}

void TargetInfoData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_target_name()) {
      if (target_name_ != &::google::protobuf::internal::kEmptyString) {
        target_name_->clear();
      }
    }
    tid_ = 0u;
    if (has_auth()) {
      if (auth_ != NULL) auth_->::TargetAuthData::Clear();
    }
  }
  params_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TargetInfoData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string target_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_target_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->target_name().data(), this->target_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_tid;
        break;
      }

      // optional uint32 tid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tid_)));
          set_has_tid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_params;
        break;
      }

      // repeated string params = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_params()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->params(this->params_size() - 1).data(),
            this->params(this->params_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_params;
        if (input->ExpectTag(34)) goto parse_auth;
        break;
      }

      // optional .TargetAuthData auth = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_auth:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_auth()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TargetInfoData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string target_name = 1;
  if (has_target_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->target_name().data(), this->target_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->target_name(), output);
  }

  // optional uint32 tid = 2;
  if (has_tid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->tid(), output);
  }

  // repeated string params = 3;
  for (int i = 0; i < this->params_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->params(i).data(), this->params(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->params(i), output);
  }

  // optional .TargetAuthData auth = 4;
  if (has_auth()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->auth(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TargetInfoData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string target_name = 1;
  if (has_target_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->target_name().data(), this->target_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->target_name(), target);
  }

  // optional uint32 tid = 2;
  if (has_tid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->tid(), target);
  }

  // repeated string params = 3;
  for (int i = 0; i < this->params_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->params(i).data(), this->params(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->params(i), target);
  }

  // optional .TargetAuthData auth = 4;
  if (has_auth()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->auth(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TargetInfoData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string target_name = 1;
    if (has_target_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->target_name());
    }

    // optional uint32 tid = 2;
    if (has_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tid());
    }

    // optional .TargetAuthData auth = 4;
    if (has_auth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->auth());
    }

  }
  // repeated string params = 3;
  total_size += 1 * this->params_size();
  for (int i = 0; i < this->params_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->params(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TargetInfoData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TargetInfoData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TargetInfoData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TargetInfoData::MergeFrom(const TargetInfoData& from) {
  GOOGLE_CHECK_NE(&from, this);
  params_.MergeFrom(from.params_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_name()) {
      set_target_name(from.target_name());
    }
    if (from.has_tid()) {
      set_tid(from.tid());
    }
    if (from.has_auth()) {
      mutable_auth()->::TargetAuthData::MergeFrom(from.auth());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TargetInfoData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TargetInfoData::CopyFrom(const TargetInfoData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TargetInfoData::IsInitialized() const {

  return true;
}

void TargetInfoData::Swap(TargetInfoData* other) {
  if (other != this) {
    std::swap(target_name_, other->target_name_);
    std::swap(tid_, other->tid_);
    params_.Swap(&other->params_);
    std::swap(auth_, other->auth_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TargetInfoData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TargetInfoData_descriptor_;
  metadata.reflection = TargetInfoData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserInfoData::kUserNameFieldNumber;
const int UserInfoData::kSecretFieldNumber;
const int UserInfoData::kTargetsFieldNumber;
const int UserInfoData::kEncodingVersionFieldNumber;
#endif  // !_MSC_VER

UserInfoData::UserInfoData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserInfoData::InitAsDefaultInstance() {
}

UserInfoData::UserInfoData(const UserInfoData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserInfoData::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encoding_version_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserInfoData::~UserInfoData() {
  SharedDtor();
}

void UserInfoData::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    delete secret_;
  }
  if (this != default_instance_) {
  }
}

void UserInfoData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserInfoData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserInfoData_descriptor_;
}

const UserInfoData& UserInfoData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

UserInfoData* UserInfoData::default_instance_ = NULL;

UserInfoData* UserInfoData::New() const {
  return new UserInfoData;
}

void UserInfoData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    if (has_secret()) {
      if (secret_ != &::google::protobuf::internal::kEmptyString) {
        secret_->clear();
      }
    }
    encoding_version_ = 0u;
  }
  targets_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserInfoData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->user_name().data(), this->user_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_targets;
        break;
      }

      // repeated string targets = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_targets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_targets()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->targets(this->targets_size() - 1).data(),
            this->targets(this->targets_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_targets;
        if (input->ExpectTag(26)) goto parse_secret;
        break;
      }

      // optional string secret = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_secret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_secret()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->secret().data(), this->secret().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_encoding_version;
        break;
      }

      // optional uint32 encoding_version = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encoding_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &encoding_version_)));
          set_has_encoding_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserInfoData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->user_name().data(), this->user_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

  // repeated string targets = 2;
  for (int i = 0; i < this->targets_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->targets(i).data(), this->targets(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->targets(i), output);
  }

  // optional string secret = 3;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->secret().data(), this->secret().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->secret(), output);
  }

  // optional uint32 encoding_version = 4 [default = 0];
  if (has_encoding_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->encoding_version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserInfoData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->user_name().data(), this->user_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->user_name(), target);
  }

  // repeated string targets = 2;
  for (int i = 0; i < this->targets_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->targets(i).data(), this->targets(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->targets(i), target);
  }

  // optional string secret = 3;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->secret().data(), this->secret().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->secret(), target);
  }

  // optional uint32 encoding_version = 4 [default = 0];
  if (has_encoding_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->encoding_version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserInfoData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // optional string secret = 3;
    if (has_secret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->secret());
    }

    // optional uint32 encoding_version = 4 [default = 0];
    if (has_encoding_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->encoding_version());
    }

  }
  // repeated string targets = 2;
  total_size += 1 * this->targets_size();
  for (int i = 0; i < this->targets_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->targets(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserInfoData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserInfoData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserInfoData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserInfoData::MergeFrom(const UserInfoData& from) {
  GOOGLE_CHECK_NE(&from, this);
  targets_.MergeFrom(from.targets_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_secret()) {
      set_secret(from.secret());
    }
    if (from.has_encoding_version()) {
      set_encoding_version(from.encoding_version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserInfoData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserInfoData::CopyFrom(const UserInfoData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfoData::IsInitialized() const {

  return true;
}

void UserInfoData::Swap(UserInfoData* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(secret_, other->secret_);
    targets_.Swap(&other->targets_);
    std::swap(encoding_version_, other->encoding_version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserInfoData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserInfoData_descriptor_;
  metadata.reflection = UserInfoData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DirtyFileData::kCleanFieldNumber;
const int DirtyFileData::kConfigFieldNumber;
const int DirtyFileData::kStoppedFieldNumber;
const int DirtyFileData::kRevisionFieldNumber;
#endif  // !_MSC_VER

DirtyFileData::DirtyFileData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DirtyFileData::InitAsDefaultInstance() {
}

DirtyFileData::DirtyFileData(const DirtyFileData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DirtyFileData::SharedCtor() {
  _cached_size_ = 0;
  clean_ = false;
  config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  stopped_ = false;
  revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirtyFileData::~DirtyFileData() {
  SharedDtor();
}

void DirtyFileData::SharedDtor() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    delete revision_;
  }
  if (this != default_instance_) {
  }
}

void DirtyFileData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DirtyFileData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DirtyFileData_descriptor_;
}

const DirtyFileData& DirtyFileData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_dedupv1d_2eproto();
  return *default_instance_;
}

DirtyFileData* DirtyFileData::default_instance_ = NULL;

DirtyFileData* DirtyFileData::New() const {
  return new DirtyFileData;
}

void DirtyFileData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    clean_ = false;
    if (has_config()) {
      if (config_ != &::google::protobuf::internal::kEmptyString) {
        config_->clear();
      }
    }
    stopped_ = false;
    if (has_revision()) {
      if (revision_ != &::google::protobuf::internal::kEmptyString) {
        revision_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DirtyFileData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool clean = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &clean_)));
          set_has_clean();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_config;
        break;
      }

      // optional string config = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_config()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->config().data(), this->config().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_stopped;
        break;
      }

      // optional bool stopped = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stopped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &stopped_)));
          set_has_stopped();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_revision;
        break;
      }

      // optional string revision = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_revision:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_revision()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->revision().data(), this->revision().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirtyFileData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool clean = 1;
  if (has_clean()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->clean(), output);
  }

  // optional string config = 2;
  if (has_config()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->config().data(), this->config().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->config(), output);
  }

  // optional bool stopped = 3;
  if (has_stopped()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->stopped(), output);
  }

  // optional string revision = 4;
  if (has_revision()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->revision().data(), this->revision().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->revision(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DirtyFileData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool clean = 1;
  if (has_clean()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->clean(), target);
  }

  // optional string config = 2;
  if (has_config()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->config().data(), this->config().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->config(), target);
  }

  // optional bool stopped = 3;
  if (has_stopped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->stopped(), target);
  }

  // optional string revision = 4;
  if (has_revision()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->revision().data(), this->revision().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->revision(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DirtyFileData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool clean = 1;
    if (has_clean()) {
      total_size += 1 + 1;
    }

    // optional string config = 2;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->config());
    }

    // optional bool stopped = 3;
    if (has_stopped()) {
      total_size += 1 + 1;
    }

    // optional string revision = 4;
    if (has_revision()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->revision());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirtyFileData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DirtyFileData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DirtyFileData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DirtyFileData::MergeFrom(const DirtyFileData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_clean()) {
      set_clean(from.clean());
    }
    if (from.has_config()) {
      set_config(from.config());
    }
    if (from.has_stopped()) {
      set_stopped(from.stopped());
    }
    if (from.has_revision()) {
      set_revision(from.revision());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DirtyFileData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DirtyFileData::CopyFrom(const DirtyFileData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirtyFileData::IsInitialized() const {

  return true;
}

void DirtyFileData::Swap(DirtyFileData* other) {
  if (other != this) {
    std::swap(clean_, other->clean_);
    std::swap(config_, other->config_);
    std::swap(stopped_, other->stopped_);
    std::swap(revision_, other->revision_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DirtyFileData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DirtyFileData_descriptor_;
  metadata.reflection = DirtyFileData_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
